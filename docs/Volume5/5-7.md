# 5-7 AdventureAPI

编者谨按，Paper 服务端系修改 Spigot 服务端而成。在文本显示方面，该服务端对原有 API 作了众多颠覆性调整。比如，Spigot 插件作者常用 `CommandSender#sendMessage(String)` 方法给玩家发送文本消息，而 Paper 团队将该方法标记为过时，并推荐 Adventure API 中的方法以替代。遭废弃的方法还包括 `Player#sendTitle(String, String)` 、`ItemMeta#setLore(List<String>)` 等等，不一一列举。这些方法对于 Spigot 插件开发者来说是不可或缺的，一旦标为过时，许多人无所适从。

有鉴于原作者 ThatRarityEG 道席常用 Paper API 编程，并在 EX-2-1 中建议读者将 Paper 服务端作为依赖，必须对这些“过时”方法的替代品作论述。原教程第五卷主要介绍前文中所未提及的一部分 Bukkit API 内的方法，故将 Adventure API 教程置于第五卷内。该卷原先只有七节，5-7 为“自定义进度”，现于 5-6 和 5-7 之间插入一节 Adventure API 教程，将“自定义进度”移至 5-8 。之所以不将新写的教程附在卷末，是因为“自定义进度”这一节有结束语，对第五卷内容作了总结，必须置尾。

编者以为，Adventure API 不宜脱离于 Paper 服务端而存在。Paper 服务端为适配 Adventure API ，对服务端源代码作了很多修改。比如，令 `org.bukkit.entity.Player` 继承于 `net.kyori.adventure.audience.Audience` 等。诚然，如果将依赖打包至插件中，那么在 Spigot 服务端上也可以使用 Adventure API ，但上述继承关系不存在，插件代码必须作调整，可能冗杂。另外，在实践中该做法较为鲜见。因此，一般而言，使用了 Adventure API 的插件，往往只能运行在 Paper 服务端上。下文不会论述如何在 Spigot 服务器上使用 Adventure API ，所有代码都仅能在 Paper 服务端上运行。

---

本节主要介绍新版中用于文本格式化以及用户界面设定相关的 `AdventureAPI`

本节只囊括 `AdventureAPI` 部分常用内容，想要查看所有用法请前往 [官方文档](https://docs.advntr.dev/)

## AdventureAPI 简介

`AdventureAPI` 是一个用于控制「用户界面元素」的库

可以很方便地在用户界面上显示各种特效

涉及内容包括但不限于：

- 聊天信息
  - 点击事件
  - 悬浮文本
  - ...
- 显示标题
- 书本内容
- 物品名称
- 物品介绍 (Lore)
- 实体显示名
- 容器界面标题
- 信息本地化（i18N）

Paper 端自版本 `1.16.5 build 473` 起 `AdventureAPI` 已内置

## 简单的使用方法

几乎所有用到文字的地方都可以使用 `AdventureAPI` 提供的 `Component` 较为方便地创建带有特效的文本

下面以创建一个功能性物品作为示范，我们要创建一把「神奇的剪刀」，在潜行时用它剪羊毛可以获得双倍产物

<details>
<summary>最终效果</summary>

![ITEM_ORIG.png](https://s2.loli.net/2023/07/21/EVtL3UwZmJMoTHl.png)

其中「左Shift」跟随客户端的「潜行」键设定

如果客户端的「潜行」键是「左Alt」，那么物品也会自动变为下面这个样子：

![ITEM_MOD.png](https://s2.loli.net/2023/07/21/szbGDyp2AjtC8uP.png)

</details>

首先声明一个物品堆

```java
var item = new ItemStack(Material.SHEARS);
```

这只是一个普通的剪刀，与从创造模式物品栏中拿出来的无异

跟上脚步，我们要修改它的 `ItemMeta` 了，你知道怎么修改吗？

```java
item.editMeta(meta -> { // 使用 lambda 表达式修改 ItemMeta，提高代码可读性
    // meta.displayName(...)
    // ...
});
```

如果你的版本不支持 `editMeta` 方法，你仍然可以使用传统的方法：

```java
var meta = item.getItemMeta();

// meta.displayName(...);
// ...

item.setItemMeta(meta);
```

然后，我们要开始设定这把剪刀的名称和介绍了

首先是展示名：

```java
meta.displayName(
        Component.text("神奇的剪刀")
            .color(NamedTextColor.BLUE));
```

从语义上不难看出，这段代码的意思就是 “设定展示名为「神奇的剪刀」，并且使用蓝色字体”

现在你可能想打开客户端和测试服务器来看看游戏内的效果了

但请别急，我们还有物品介绍没有完成！

现在你已经知道怎么添加彩色物品名了，那么介绍如法炮制：

```java
meta.lore(List.of( // 使用 Java 9 新增的工厂函数构造一个 List
        Component.text(""), // 空行
        Component.text("使用 Shift + 右键 来剪下更多羊毛").color(NamedTextColor.YELLOW)
));
```

有人可能会说，一直用原版的配色，太单调了，就不能用 RGB 吗？

确实，我们刚刚一直在使用 `NamedTextColor` 枚举来引用原版内置的几种颜色

这么做显然很方便，但同时也会使用户界面比较枯燥

因此我们可以使用 `TextColor.color(int)` 方法来给字符着色

你可以去 [sojson](https://www.sojson.com/rgb.html) 获取颜色的 16 进制代码

```java
Component.text("使用 Shift + 右键 来剪下更多羊毛")
        .color(TextColor.color(0xFFFACD)) // 以 0x 开头会将后面的 16 进制整数转换成 10 进制
```

现在你可以去测试了，不过记得要先创建一个获取这个物品的途径，用上你前面学过的知识，比如在玩家进服的时候给予这个物品堆：

```java
@EventHandler
public void onJoin(PlayerJoinEvent evt) {

    // var item = ...
    evt.getPlayer().getInventory().addItem(item);

}
```

或许我们需要给这个进服的玩家（也就是前来测试的你自己）作一些提示

你应该知道的，我们可以用 `sendMessage()` 方法：

```java
// 可以在 TextComponent 上使用 `.append()` 方法来拼接另外一个 TextComponent
var prefix = Component.text("[").color(NamedTextColor.GRAY)
        .append(Component.text("提醒").color(NamedTextColor.WHITE))
        .append(Component.text("] ").color(NamedTextColor.GRAY));
p.sendMessage(prefix.append(Component.text("你收到了一件物品!").color(NamedTextColor.YELLOW)));
```

注册好你的监听器，然后冲进本地测试服务器

![MESSAGE.png](https://s2.loli.net/2023/07/21/R4CGpBg38encyZ1.png)

提示信息如期播报，那么物品呢？

是的，我们也拿到物品了！但是......我想你也注意到了，物品上的文字都是斜体的

这是因为 `displayName` 和 `lore` 在被设定的时候，也被自动加上了斜体标签

那么我们只要在开头取消这个斜体即可

```java
Component.text("神奇的剪刀")
        .color(NamedTextColor.BLUE)
        .decoration(TextDecoration.ITALIC, false) // 将「斜体」属性设为「假」
```

结束了......吗？

不，还有一个问题，客户端是可以自定义按键的，如果玩家设定的「潜行」键不是 `Shift`，那该怎么办？

如你所愿，`AdventureAPI` 也提供了获取用户按键绑定的方法，这次不是 `Component.text()` 了，请看：

```java
Component.keybind("key.sneak")
```

这回返回一个 `KeybindComponent`，将其和我们的 `TextComponent` 拼接起来，我们依然使用 `.append()` 方法

```java
Component.text("使用 ").color(TextColor.color(0xFFFACD)).decoration(TextDecoration.ITALIC, false)
        .append(Component.keybind("key.sneak"))
        .append(Component.text(" + "))
        .append(Component.keybind("key.mouse.right"))
        .append(Component.text(" 来剪下更多羊毛"))
```

至此，物品创建已经结束，下面是完整的代码：

```java
var item = new ItemStack(Material.SHEARS);
item.editMeta(meta -> {
        meta.displayName(
                Component.text("神奇的剪刀")
                        .color(NamedTextColor.BLUE).decoration(TextDecoration.ITALIC, false));

        meta.lore(List.of(
                Component.text(""), // 空行
                Component.text("使用 ").color(TextColor.color(0xFFFACD)).decoration(TextDecoration.ITALIC, false)
                        .append(Component.keybind("key.sneak"))
                        .append(Component.text(" + "))
                        .append(Component.keybind("key.mouse.right"))
                        .append(Component.text(" 来剪下更多羊毛"))
        ));
});
```

## MiniMessage

上面这个简单的例子已经充斥着啰嗦的调用，如果要创建更复杂的内容，那还得了！有没有更简单的方法？

`MiniMessage` 应运而生，它将近似旧版的文本格式化带进了高版本，同时新增了多个高级功能

欲查看全部用法请查阅 [官方文档](https://docs.advntr.dev/minimessage/format.html)

例如上面这个例子，我们可以利用 `MiniMessage` 改写成：

```java
var mm = MiniMessage.miniMessage(); // 注意这个方法的返回结果可以被重复使用，建议将其放在插件主类中作为静态字段来避免重复创建 `MiniMessage` 对象
var item = new ItemStack(Material.SHEARS);
item.editMeta(meta -> {
        meta.displayName(mm.deserialize("<!italic><blue>神奇的剪刀")); // `!` 表示否定，即取消「斜体」效果
        meta.lore(List.of(
                Component.text(""),
                mm.deserialize("<!italic><color:#FFFACD>使用 <key:key.sneak> + <key:key.mouse.right> 来剪下更多羊毛")
                // 这里使用 `color` 标签指定 RGB 颜色，别忘了添加 `#` 前缀符号
                // `key` 标签则表示一个快捷键
        ));
});
```

## 序列化

使用 `AdventureAPI` 时一个常见的问题就是如何将一串 `Component` 转换为 `String`

你可能想到了 `Component.toString()` 方法

但是很遗憾，这样输出的东西包含了元数据，并不是我们想要的纯文本

此时需要使用 `PlainTextComponentSerializer`，使用方法很简单：

```java
var plain = PlainTextComponentSerializer.plainText().serializer(Component.text("test"));
getLogger().info(plain);
```

除了 `PlainTextComponentSerializer`，还有多种 `Serializer`，比如 `JSONComponentSerializer`

它可以将 `Component` 转化为 `json` 字符串，就是你在「命令方块」里敲的那种：

```java
var json = JSONComponentSerializer.json().serialize(Component.text("test").color(NamedTextColor.BLUE));
getLogger().info(json);
```
