# 5-4 药水效果

Bukkit 中所有的药水效果都通过 `PotionEffect` 进行描述。

## 使用原版药水效果

要使用一个已经存在的药水效果，我们只需要实例化 `PotionEffect` 并进行应用即可。

下面演示如何给一名玩家「迅捷 II」效果，首先创建药水效果的实例：

```java
PotionEffect pe = new PotionEffect(PotionEffectType.SPEED, 100, 1);
```

其中，所有的药水效果种类都定义在 `PotionEffectType` 类中。可以通过 JavaDocs 查找可能的值。

我们来看看构造方法的签名：

```java
public PotionEffect(
    @NotNull PotionEffectType type,
    int duration,
    int amplifier,
    boolean ambient, // 可选
    boolean particles, // 可选
    boolean icon // 可选
)
```

六个参数分别是：

- 药水类型，只能使用 `PotionEffectType` 中的静态成员变量
- 持续时间，单位刻
- 倍率，对于有等级的效果（如「力量」），该数字比等级小 1，对于没有等级的效果，设置为 0
- 是否进行渲染，可选，如果为 `true` 将产生更多的粒子，如果不填，默认为 `true`
- 是否具有粒子，可选，似乎会影响客户端的渲染，具体作用尚不明确
- 是否具有图标，可选，似乎会影响客户端在背包界面是否显示该效果，具体作用尚不明确

一般而言，填写三个参数就足够了。

要使用这个药水效果，只需要在合适的时机进行应用：

```java
pe.apply(Objects.requireNonNull(Bukkit.getPlayer("ThatRarityEG")));
```

药水效果实际上不仅能用于玩家，还能用于任何 `LivingEntity` 的实例。

## 自定义药水效果

Bukkit 没有提供自定义药水效果的方法，但我们可以自己创建。

::: tip <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1028 1024' transform='scale(0.6)' fill='%23fff'%3E%3Cpath d='M1018.319924 112.117535q4.093748 9.210934 6.652341 21.492179t2.558593 25.585928-5.117186 26.609365-16.374994 25.585928q-12.281245 12.281245-22.003898 21.492179t-16.886712 16.374994q-8.187497 8.187497-15.351557 14.32812l-191.382739-191.382739q12.281245-11.257808 29.167958-27.121083t28.144521-25.074209q14.32812-11.257808 29.679676-15.863275t30.191395-4.093748 28.656239 4.605467 24.050772 9.210934q21.492179 11.257808 47.589826 39.402329t40.425766 58.847634zM221.062416 611.554845q6.140623-6.140623 28.656239-29.167958t56.289041-56.80076l74.710909-74.710909 82.898406-82.898406 220.038979-220.038979 191.382739 192.406177-220.038979 220.038979-81.874969 82.898406q-40.937484 39.914047-73.687472 73.175753t-54.242167 54.753885-25.585928 24.562491q-10.234371 9.210934-23.539054 19.445305t-27.632802 16.374994q-14.32812 7.16406-41.960921 17.398431t-57.824197 19.957024-57.312478 16.886712-40.425766 9.210934q-27.632802 3.070311-36.843736-8.187497t-5.117186-37.867173q2.046874-14.32812 9.722653-41.449203t16.374994-56.289041 16.886712-53.730448 13.304682-33.773425q6.140623-14.32812 13.816401-26.097646t22.003898-26.097646z'/%3E%3C/svg%3E" style="background-color:#057E3D; clip-path: circle();" width="24px" height="24px"> **编者注**
谨按，继承 `PotionEffect` 是不可取的。具体解释见下方。

下文部分代码有效性存疑，已经在注解中一一指出。阅读时幸勿直接复制代码。
:::

下面演示如何创建「EEE」效果，该效果在玩家获取 10 秒之后发送大量的字母「e」。（致敬咏士）

首先，由于我们要创建的是药水效果，因此需要创建一个类来描述它。

```java
public class EEEEffect extends PotionEffect {
    public EEEEffect() {
        super(PotionEffectType.BAD_OMEN, 100, 0);
    }
}
```

`super` 指的是「使用父类的构造方法」，也就是「采用传统的方法」。

这里的 `PotionEffectType` 是药水类型（主要决定图标），插件无法修改（Bukkit 写死在代码里面了），因此只能选择一个已有的。这里我们选择的是「不祥之兆」。

持续时间和等级无所谓，因为我们不会用到它，随便传两个值就可以了。

下面是重中之重！

要实现我们自己的效果，需要**重写** `apply` 方法。

示例如下：

```java
public class EEEEffect extends PotionEffect {
    public EEEEffect() {
        super(PotionEffectType.BAD_OMEN, 100, 1);
    }
    
    @Override
    public boolean apply(LivingEntity entity) {
        if (entity instanceof Player) {
            entity.sendMessage("您即将受到 EEE 效果的影响！");
            // 计划任务，从此开始
            new BukkitRunnable() {
                @Override
                public void run() {
                    for (int i = 1; i <= 10; i++) {
                        entity.sendMessage("eeeeeeeeeeeeeeee（后略）");
                        // 发送消息
                    }
                }
            }.runTaskLaterAsynchronously(<插件主类名>.instance, 200);
            // 到此结束
            return true; // 可以被添加
        }
        return false; // 不可被添加
    }
}
```

基本上只需要注意三个点：

- 如果这个效果成功被添加，返回 `true`，否则返回 `false`，这似乎会影响到 Bukkit 的游戏判断，因此请如实返回
- `apply` 方法只会**在药水生效的瞬间被调用一次**，如果要像「力量」那样持续生效，有几个办法：
  - 创建一个 `List<UUID>` 记录有这个效果的实体，并通过 Bukkit 的计划任务在一定时间后移除，然后监听事件，通过查询这个 `List` 对实体的行为进行相应的修改
  - 将数据通过 NBT 绑定到实体上，并通过 Bukkit 的计划任务在一定时间后移除，然后监听事件，通过查询 NBT 对实体的行为进行相应的修改
- 一定要记得加 `@Override`

那什么是 Bukkit 的计划任务呢？

Bukkit 计划任务用于「在一段时间后执行某个操作」，我们在 4-2 和 AC-1-1 中见到过它的「异步执行」版本。计划任务的写法和异步执行非常相似：

```java
new BukkitRunnable() {
    @Override
    public void run() {
        // 要做之事……
    }
}.runTaskLaterAsynchronously(<插件主类名>.instance, 200); // 200 是要推迟的时间，单位刻
```

这样就不难解释我们上面的效果了，我们让 Bukkit 向玩家发送许多「e」，并将这个操作推迟了 10 秒（200 刻）。

好啦！这样药水效果就创建完了，不需要注册！

将这个效果直接应用给玩家：

```java
new EEEEffect().apply(Objects.requireNonNull(Bukkit.getPlayer("ThatRarityEG")));
```

::: tip <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1028 1024' transform='scale(0.6)' fill='%23fff'%3E%3Cpath d='M1018.319924 112.117535q4.093748 9.210934 6.652341 21.492179t2.558593 25.585928-5.117186 26.609365-16.374994 25.585928q-12.281245 12.281245-22.003898 21.492179t-16.886712 16.374994q-8.187497 8.187497-15.351557 14.32812l-191.382739-191.382739q12.281245-11.257808 29.167958-27.121083t28.144521-25.074209q14.32812-11.257808 29.679676-15.863275t30.191395-4.093748 28.656239 4.605467 24.050772 9.210934q21.492179 11.257808 47.589826 39.402329t40.425766 58.847634zM221.062416 611.554845q6.140623-6.140623 28.656239-29.167958t56.289041-56.80076l74.710909-74.710909 82.898406-82.898406 220.038979-220.038979 191.382739 192.406177-220.038979 220.038979-81.874969 82.898406q-40.937484 39.914047-73.687472 73.175753t-54.242167 54.753885-25.585928 24.562491q-10.234371 9.210934-23.539054 19.445305t-27.632802 16.374994q-14.32812 7.16406-41.960921 17.398431t-57.824197 19.957024-57.312478 16.886712-40.425766 9.210934q-27.632802 3.070311-36.843736-8.187497t-5.117186-37.867173q2.046874-14.32812 9.722653-41.449203t16.374994-56.289041 16.886712-53.730448 13.304682-33.773425q6.140623-14.32812 13.816401-26.097646t22.003898-26.097646z'/%3E%3C/svg%3E" style="background-color:#057E3D; clip-path: circle();" width="24px" height="24px"> **编者注**
谨按，覆写 `apply` 方法是不可取的。具体解释见下方。

如果要让玩家发送很多个 e，没有必要写 `EEEEffect` 类。直接新建一个 `PotionEffect` 对象，然后调用 `apply` 即可。接着将 `sendMessage` 语句附在 `apply` 之后。例如：

```java
new PotionEffect(PotionEffectType.BAD_OMEN, 100, 1).apply(Bukkit.getPlayer("ThatRarityEG"));
```
:::

## 将效果与药水绑定

现在重新看看 3-2 中的内容，是不是恍然大悟了？

其实，创建一瓶「咏 e」药水也不难嘛……唰唰唰就写出来了：

```java
ItemStack ePotion = new ItemStack(Material.SPLASH_POTION);
// 喷溅型咏 E 药水，Minecraft 会自动判断受影响的实体，想想就很好玩啊！
PotionMeta pm = (PotionMeta) ePotion.getItemMeta();
pm.setColor(Color.fromRGB(225, 0, 0)); // 危险的红色
pm.setBasePotionData(new PotionData(PotionType.WATER));
// 不需要任何预设效果，使用 WATER，请区分 PotionType 和 PotionEffectType！
pm.addCustomEffect(new EEEEffect(), true); // 加入我们自定义的药水效果
pm.setDisplayName("喷溅的咏 e 药水");
pm.setLore(Collections.singletonList(ChatColor.GRAY + "eee……eeee？"));
// 灰色的介绍
ePotion.setItemMeta(pm);
```

*`Collections.singletonList` 创建一个单项只读列表。*

对于药水究竟怎么「喷溅」，「喷溅」到谁身上，那是 Bukkit 来决定的啦~

现在 `ePotion` 就是一个「喷溅的咏 e 药水」啦！想怎么使用就由你决定啦~

例如，将它给予一个玩家：

```java
Objects.requireNonNull(Bukkit.getPlayer("ThatRarityEG"))
    .getInventory()
    .addItem(ePotion);
```

将它对着自己丢出来试试吧！

::: tip <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1028 1024' transform='scale(0.6)' fill='%23fff'%3E%3Cpath d='M1018.319924 112.117535q4.093748 9.210934 6.652341 21.492179t2.558593 25.585928-5.117186 26.609365-16.374994 25.585928q-12.281245 12.281245-22.003898 21.492179t-16.886712 16.374994q-8.187497 8.187497-15.351557 14.32812l-191.382739-191.382739q12.281245-11.257808 29.167958-27.121083t28.144521-25.074209q14.32812-11.257808 29.679676-15.863275t30.191395-4.093748 28.656239 4.605467 24.050772 9.210934q21.492179 11.257808 47.589826 39.402329t40.425766 58.847634zM221.062416 611.554845q6.140623-6.140623 28.656239-29.167958t56.289041-56.80076l74.710909-74.710909 82.898406-82.898406 220.038979-220.038979 191.382739 192.406177-220.038979 220.038979-81.874969 82.898406q-40.937484 39.914047-73.687472 73.175753t-54.242167 54.753885-25.585928 24.562491q-10.234371 9.210934-23.539054 19.445305t-27.632802 16.374994q-14.32812 7.16406-41.960921 17.398431t-57.824197 19.957024-57.312478 16.886712-40.425766 9.210934q-27.632802 3.070311-36.843736-8.187497t-5.117186-37.867173q2.046874-14.32812 9.722653-41.449203t16.374994-56.289041 16.886712-53.730448 13.304682-33.773425q6.140623-14.32812 13.816401-26.097646t22.003898-26.097646z'/%3E%3C/svg%3E" style="background-color:#057E3D; clip-path: circle();" width="24px" height="24px"> **编者注**
谨按，上述代码根本不可能创建出一瓶「咏 e」药水。据编者 CaveNightingale 测试，药水效果无法添加到物品堆上，对自己丢出来之后也没有效果。这是因为 `PotionEffect` 类形如 Java 17 中的 `Record`，所谓 `apply` 方法根本没有用武之地。

一个药水瓶可以容纳多个药水效果。因而 `PotionMeta` 类用列表来记录它们。当调用 `PotionMeta#addCustomEffect` 方法时，无论参数是 `PotionEffect` 对象还是 `EEEEffect` 对象，都先暂存进列表里。当调用 `ItemStack#setItemMeta` 方法时，就将各个 `PotionEffect` 对象序列化为 NBT 形式，保存到物品堆 NBT 数据中。回首 4-1 节，ThatRarityEG 道席已经介绍了物品堆的 NBT 数据。NBT 数据类型有限，只有 Map、List、String、Number 等。所以，服务端会用数字形式保存 `PotionEffectType` 的 `id`、药效的时长、药效的等级……然后汇总到一个 NBTTagCompound 里。所以在修改药水瓶物品堆的数据时，`PotionEffect` 类只不过起到了传递数据的作用。用户通过构造器来指定 `PotionEffectType`、药效时长、药效等级之类的参数，然后服务端调用 getter 方法来获取它们。根本不涉及 `apply` 方法。

那么当药水喷溅而出，服务端要赋予玩家药水效果时该怎么办？此时服务端根本不需要 Bukkit 里的 `PotionEffect` 类。直接读取 NBT 数据，构造出 NMS 里的 `MobEffect`（近似于 `PotionEffect` 的类），然后应用在实体身上。就算是有 `PotionEffect` 对象，那么服务端根据 `id` 获得 `PotionEffectType`，辅以等级、时长等参数，构建一个新的 `PotionEffect` 对象时，怎么知道 `EEEEffect` 这个类的存在呢？就算有某种办法把 `EEEEffect` 注册到服务端里，那服务端要实例化 `PotionEffect` 时，什么情况下用 `EEEEffect`、又在什么情况下用 `PotionEffect` 呢？

所以，再怎么覆写 `apply` 方法都没有用。归根到底，`PotionEffect` 类只是传递数据用的。药水瓶物品堆的数据保存在 NBT 里，如果 Bukkit 开发者要用了，就构造一个`PotionEffect` 提供一些 getter。又比如 Bukkit 开发者要写一个药水瓶物品堆，那就自己构造一个 `PotionEffect` 对象，服务端读取其中的数据写进 NBT 里，然后舍弃这个对象。

既然玩家喝下药水、喷溅药水溅射到玩家身上时，服务端都不需要 `apply` 方法，那这个方法究竟在什么时候使用？查看源代码，发现它其实就是 `LivingEntity#addPotionEffect` 方法的包装。它是供插件开发者手动调用的。如果你有一个 `PotionEffect` 对象，想要给某实体赋予该效果，那就调用 `apply` 方法。因此，上述「将这个效果直接应用给玩家」的代码是 `apply` 方法的正确应用示范，只不过不必继承 `PotionEffect` 再覆写。因为当你自己调用该方法时，可以直接将额外要执行的代码（发送很多个字母 e）附在 `apply` 方法以后。

综上所述，没有必要再将这瓶药水对着自己丢出来，因为不会有效果。
:::

效果大概是这样的（1.16.5 原版<s>，资源包是 Love-And-Tolerance</s>）：

![RESULT.png](https://s2.loli.net/2023/06/19/j9h3XFRs2Qx6n1E.png)

![EEE.png](https://s2.loli.net/2023/06/19/4f9zo8JaUsPipHb.png)

::: tip <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1028 1024' transform='scale(0.6)' fill='%23fff'%3E%3Cpath d='M1018.319924 112.117535q4.093748 9.210934 6.652341 21.492179t2.558593 25.585928-5.117186 26.609365-16.374994 25.585928q-12.281245 12.281245-22.003898 21.492179t-16.886712 16.374994q-8.187497 8.187497-15.351557 14.32812l-191.382739-191.382739q12.281245-11.257808 29.167958-27.121083t28.144521-25.074209q14.32812-11.257808 29.679676-15.863275t30.191395-4.093748 28.656239 4.605467 24.050772 9.210934q21.492179 11.257808 47.589826 39.402329t40.425766 58.847634zM221.062416 611.554845q6.140623-6.140623 28.656239-29.167958t56.289041-56.80076l74.710909-74.710909 82.898406-82.898406 220.038979-220.038979 191.382739 192.406177-220.038979 220.038979-81.874969 82.898406q-40.937484 39.914047-73.687472 73.175753t-54.242167 54.753885-25.585928 24.562491q-10.234371 9.210934-23.539054 19.445305t-27.632802 16.374994q-14.32812 7.16406-41.960921 17.398431t-57.824197 19.957024-57.312478 16.886712-40.425766 9.210934q-27.632802 3.070311-36.843736-8.187497t-5.117186-37.867173q2.046874-14.32812 9.722653-41.449203t16.374994-56.289041 16.886712-53.730448 13.304682-33.773425q6.140623-14.32812 13.816401-26.097646t22.003898-26.097646z'/%3E%3C/svg%3E" style="background-color:#057E3D; clip-path: circle();" width="24px" height="24px"> **编者注**
有鉴于图床失效、原图丢失，上图系定稿后再行修补，截图时未使用前述资源包。

虽然上述代码是无效的，但编者谨据文字描述模拟了预期效果并截图。
:::