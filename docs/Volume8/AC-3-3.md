# AC-3-3 CuteCoin Part 3

## 启动服务端

将「CuteCoin」丢进 `plugins` 文件夹，启动一次服务端，**保存服务端打开**。

修改配置文件，输入合适的值（这里我只配置了 MySQL）：

```yaml
mysql:
  use: true # false 以使用文件，true 以使用 MySQL
  host: localhost # 数据库主机
  db-name: cutecoin # 数据库名
  username: root # 用户名
  password: mylittlepony # 密码，这个根据你自己的设置
  port: 3306 # 端口
  save-threshold: 30 # 数据库写入缓存时间，0 以禁用（仅在关闭时保存）
```

同时我们还要在数据库中创建新的数据库：

```sql
CREATE DATABASE cutecoin;
```

**别急着重启服务器**，在控制台输入：

```
/reload confirm
```

等一小会，配置就被重新加载了，这个指令也适用于插件代码的修改，怎么样，是不是很方便？

注：reload 指令可以用于热重载插件。服务端运行该指令时，会卸载各个插件，然后重新启动它们。在这一过程中，配置文件被重新读取。所谓「插件代码的修改」，是指开发者在 IDE 里修改插件的源代码并编译出一个新 Jar 文件以后，粘贴到服务端 plugins 目录内以替换原 Jar 文件的过程。开发者修改代码、编译、粘贴并替换文件时，无需关闭服务器。替换文件后，执行 reload 指令，即可卸载旧的插件，改用新的 Jar，运行新的代码。「热重载」一词，强调重载插件时无需关服。与热重载相对的，是重启服务器。关闭服务器时插件自然会被卸载，开启服务器时自然要加载插件。因而在服务器关闭之后、开启以前，可以修改配置、替换旧 Jar 。开服时就能读取新配置、运行新的代码。

reload 指令并不完善，常常导致匪夷所思的问题。比如 William_Shi 调试自己的某个插件时发现，使用该指令会导致 `StackOverFlowError`，且没有任何报错堆栈，无法排查原因。又如，粘液科技插件的作者表示，如果使用该指令来安装粘液科技插件，可能会导致内存泄漏。详见 [Slimefun4 Wiki](https://github.com/Slimefun/Slimefun4/wiki/Installing-Slimefun#how-to-install) 中的内容。像 Plugman、Yum 等插件也是大同小异，它们是用于热重载插件的插件，提供了在服务端运行时加载、卸载单个插件的功能，但也不可能保证重载插件时不出问题。

编者谨按，用于重载插件的最好方法必然是重启服务器。如果一个插件在开启服务器时不产生报错，在服务端正常关闭时能恰当卸载，那就足够。至于输入 reload 指令后，无论产生什么报错，又何伤乎？在调试插件时，如果每次都重启服务器，往往失之低效，因此才把 reload 指令作为无可奈何的选择，惟有「方便」这一优点。而「稳定」则根本无从谈起。任何一个服主，如果要向自己的生产环境服务端内添加一个新插件，都应该重新启动服务器。（生产环境指正式上线给用户使用的程序，调试环境指内部测试的程序）。所以对插件开发者而言，只要插件在重启服务器时不会出错，就堪称合格。

重新加载之后：

![SUCDB.png](https://s2.loli.net/2022/04/15/Fqn7c9IuvrVkT8U.png)

看上去是个不错的开始！

## 开始测试

打开 Minecraft 客户端，加入服务器。

## 然后呢？

<script setup>
    import { ref } from 'vue';
    const count = ref(0);
    const txt = [
        "单击开始事件还原",
        "RarityEG：这次轮到你了。",
        "RarityEG：找出程序 Bug 的方法，我在 AC-1-3 和 AC-1-4 中有提到过。",
        "RarityEG：……",
        "RarityEG：让我看看你的能力，就当是结业考试吧。",
        "事件模拟已结束——单击重新模拟"
    ];
</script>

<div @click.native="count++;" class="btn-event">{{ txt[count % 6] }}</div>

虽然笔者也可以把调试的过程放在这里，但笔者更想看看你解决问题的能力。

---

不知道如何下手？这里有些小提示：

- 在聊天栏输入「货币名 数量」就可以获得相应的货币（测试使用）。
- 试试看，你会发现**数据似乎无法正常保存**，试着用 `info` 方法输出 `DIRTY_LIST` 的值，看看到底哪里出了问题吧！
- 为这个插件添加 API 和 CLI，以及 OP 用的指令。
- 测试完工后，记得**删除测试代码**！（不然就成了后门了！）

我没有把完整的源代码仓库放在这里，因为源代码实际上在前面都已经展示了，笔者认为，如果你不亲手改好一个插件，你是无法体会到插件开发成功后的那种成就感的。另外，**亲手输入代码**，单纯的复制粘贴是没有用的！

## 行动结束

（一定要改完了再按这个按钮啊）

<button type='button' class="btn-unconfirmed" style="width:100%;transition:500ms;" onclick="this.innerHTML=' ✓ 恭喜！';document.getElementById('hiddenEle').style.display = 'block';this.className='btn-confirmed';this.onclick=function(){};"> ❔ 确认行动结束 </button>

<div id='hiddenEle' style='display:none;'>

> 行动结果：最终胜利！

恭喜！我想到这个时候你应该非常激动，嗯，这是你应得的。

到此为止，本教程的主要部分就落下帷幕了，听一首歌，然后前往最后一章，笔者还有一点想说的。

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100%" height="86" src="//music.163.com/outchain/player?type=2&id=28077561&auto=0&height=66"></iframe>

</div>