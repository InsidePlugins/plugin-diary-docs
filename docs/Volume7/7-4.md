# 7-4 线程安全性

Bukkit 服务器在运行时拥有数量庞大的线程，多线程使得程序从**串行**变为**并发**，合理利用了 CPU 的管道机制和多核性能。

::: danger <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' transform='scale(0.6)' fill='%23fff'%3E%3Cpath d='M10 14C10 15.1 9.1 16 8 16 6.9 16 6 15.1 6 14 6 12.9 6.9 12 8 12 9.1 12 10 12.9 10 14Z'/%3E%3Cpath d='M10 1.6C10 1.2 9.8 0.9 9.6 0.7 9.2 0.3 8.6 0 8 0 7.4 0 6.8 0.2 6.5 0.6 6.2 0.9 6 1.2 6 1.6 6 1.7 6 1.8 6 1.9L6.8 9.6C6.9 9.9 7 10.1 7.2 10.2 7.4 10.4 7.7 10.5 8 10.5 8.3 10.5 8.6 10.4 8.8 10.3 9 10.1 9.1 9.9 9.2 9.6L10 1.9C10 1.8 10 1.7 10 1.6Z'/%3E%3C/svg%3E" style="background-color:#DA0B50; clip-path: circle();" width="24px" height="24px"> **误区警示**
很多人认为，多线程只不过是 CPU 在多个线程之间切换，因此并不能提升性能，**这种观点是错误的**。

1. 首先，一个 CPU 可能有很多内核，它们可以同时进行处理。
2. 其次，CPU 解释机器指令（32 位或 64 位）时采用管道机制，即当前指令还在执行时，就开始解释下一条乃至再下一条指令，也可以实现并行。
3. 最后，涉及到磁盘、网卡等设备的外部 IO 操作时，有些电脑使用 DMA 技术，CPU 就可以不必参与数据读取的全过程，这时候 CPU 如果闲着还不如把处理能力放在其它的线程上。
4. 最重要的，**多线程使得多任务成为可能**，这对于非阻塞的事件驱动系统（如 Bukkit）是**相当重要的**，如果不能进行多任务，就会出现类似于当一个玩家移动时，其它玩家移动不了的情况。

所以，无论多线程是否能够带来性能上的提升，多线程都是必要的。而且事实证明，合理的多线程确实提升了速度。
:::

Bukkit 中实现多线程的方法很多，但最常用的是重写 `BukkitRunnable` 类并进行 `runTask`、`runTaskLater`、`runTaskAsynchronously`、`runTaskLaterAsynchoronously` 等等。这个你应该已经见到过很多很多很多次了。因此，我不准备再讲一遍如何实现多线程了。

我们今天要讨论的问题更重要：**线程安全**。

## 什么是线程安全

*以下内容摘自维基百科。*

> 线程安全是程式设计中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。

也就是说，**多个**线程使用**同一个**变量，而不会导致冲突。

说得形象一点，这就像几个人共用一个洗手间。

- 线程安全：先到的人（线程）进去在里面把门关上，其它人（线程）需要等待
- 线程不安全：洗手间没有门，所有人（线程）一哄而上，后果……

一般情况下，多个线程访问同一个数据是**不安全的**。几个线程一起写数据，就可能会出现未知的后果。

要使得线程安全，我们就需要考虑不安全的条件：

- 多个线程**共享一个**数据变量
- 这些线程同时对数据变量进行操作

那我们只需要破坏这两个条件之一就可以了。事实上在 Java 的世界中，已经有了这样的方法。

- 破坏第一个条件：**为每个线程分配单独的数据**（各用各的，谁也别抢， HarmonyAuth SMART 中 `IDataManager` 每次重新创建就是用的这种方法）
- 破坏第二个条件：**同步锁**（一次一个，其它等着，HarmonyAuth SMART 中 `sti` 和 `cli` 方法前面的 `synchronized` 就是这样做的）

下面我们依次介绍这两种方法。

## 为每个线程分配单独的数据

这个方法适用于那些**并不真正需要共享的**数据。例如 `IDataManager` 这样的工具对象，或者**需要读取但不需要写入**的对象。

在一个线程开始时（通常是 `BukkitRunnable` 中的 `run` 方法开头），对于可以单独分配的数据，应该**立即创建或复制**。

虽然分配单独的数据很简单，也不能做到数据共享，但它确实能够解决大部分不需要共享的数据的多线程访问的问题。

## 同步锁

在一个方法前面加上 `synchronized` 就可以**一次只允许一个线程调用该方法**，将操作共享数据的方法放在里面就可以了。

例如：

```java
private static List<String> someList = new ArrayList<>();

public synchronized String get(int index) {
    return someList.get(index);
}

public synchronized void set(int index, String s) {
    someList.set(index, s);
}

public synchronized void add(String s) {
    someList.add(s);
}
```

这样 `someList` 得到保护，这三个同步方法（`get`、`set` 和 `add`）保证一次只能有一个线程读写 `someList`。

上面的方法很麻烦，而且还容易忘掉这样写，幸运的是，有人已经为我们完成了这项工作，这就是第三种方法……

## 使用线程安全的实现

有些类在设计时就已经考虑到了多线程的情况，这些类通常可以处理多个线程同时访问（实际上是内部用了同步锁或者更高级的技巧）。

`ArrayList` 是我们常用的一个 `List` 的实现，但很遗憾，虽然它很快，但它**不是线程安全的**。

与 `ArrayList` 相比，另一个 `List` 的实现 `Vector` 具有和 `ArrayList` 一样的功能，但它**是线程安全的**。这也就是说，「放心地让多个线程去读写它吧，没有问题的」。`Vector` **内部已经处理了多线程的情况**。我们只需要 `new`，之后就可以在多个线程里面同时对它进行 `set`、`add` 等等操作了，不需要同步锁什么的，是不是很方便？

下面列出了一些常见的，非线程安全类的替代品：

| 非线程安全的类              | 线程安全的替代品                                             |
| --------------------------- | ------------------------------------------------------------ |
| `ArrayList`（速度很快）     | `Vector`（速度较慢）<br/>`Stack`（速度较慢）                 |
| `HashMap`（速度很快）       | `ConcurrentHashMap`（并发，速度略慢）<br/>`Hashtable`（速度较慢） |
| `StringBuilder`（速度较快） | `StringBuffer`（速度较慢）                                   |

注：原文中，`HashMap` 的第二个替代品是 `HashTable` 。谨按，Java 标准库中只有 `java.util.Hashtable` ，没有 `java.util.HashTable` ，疑为字母大小写笔误。此处依照 Java 标准库改正。表格内空间较小，故不保留原文。

~~此外，`Collections` 的 `synchronizedCollection` 方法可以「复制」一个线程安全的 `Collection`，注意，这是**复制**（创建一个新的），并不是就地修改。~~

~~`List` 也是一种 `Collection`，因此这个方法可以从已有的 `List` 对象创建一个数据不变的、新的、线程安全的对象。当然了，这样做速度会有所损失。~~

注：原文中，对 `synchronizedCollection` 方法的介绍有误。该方法并非复制，而是包装。下文依照 Java 官方文档及标准库源代码改正。上方加删除线的两行是原文。

此外，`Collections` 的 `synchronizedCollection` 方法可以「包装」一个线程**不**安全的 `Collection`，使之变得线程安全。注意，这是**包装**，是就地修改。

比如：

```java
List<Integer> ints = new ArrayList<>();
Collection<Integer> wrapper = Collections.synchronizedCollection(ints);
wrapper.add(1);
wrapper.add(2);
wrapper.add(3);
```

然后，`ints` 列表就变成了 [1, 2, 3] ，有三个元素，不再是空列表了。对于 `wrapper` 的操作直接体现在了被包装的 `ints` 列表上。

这是因为 `synchronizedCollection` 方法是根据已有的集合，包装出线程安全的对象。源代码大约是这样的（有删改）：

```java
static class SynchronizedCollection<E> implements Collection<E>, Serializable {
    final Collection<E> c;  // Backing Collection
    final Object mutex;     // Object on which to synchronize

    SynchronizedCollection(Collection<E> c) {
        this.c = Objects.requireNonNull(c);
        mutex = this;
    }

    public boolean add(E e) {
        synchronized (mutex) {return c.add(e);}
    }

    public boolean remove(Object o) {
        synchronized (mutex) {return c.remove(o);}
    }
}
```

也就是说，`SynchronizedCollection` 实际上不会存储数据，数据都在原来的 `c` 集合里（也就是上述的 `ints` 集合）。添加、删除数据，都调用 `c` 集合自身的相应方法。只不过调用以前先以 `synchronized` 给自身上锁，这样，同一时间就只能有一个线程调用这个 `SynchronizedCollection` 所提供的任何方法。一个线程在 `add` 时，其余线程既不能 `add` 也不能 `remove` 。线程安全得以实现。当然了，这样做速度会有所损失。

---

总之，线程安全是个麻烦事，在 `new BukkitRunnable` 之后**一定要确认你的代码是不是线程安全的**！如果不安全，最简单的方法就是**把那个共享的变量改成诸如 `Vector` 这样的线程安全的实现**。