import{_ as s,o,c as a,S as n}from"./chunks/framework.7f03344f.js";const h=JSON.parse('{"title":"2-1 配置文件与 JavaDocs","description":"","frontmatter":{},"headers":[],"relativePath":"Volume2/2-1.md","filePath":"docs/Volume2/2-1.md","lastUpdated":1698403164000}'),e={name:"Volume2/2-1.md"},t=n(`<h1 id="_2-1-配置文件与-javadocs" tabindex="-1">2-1 配置文件与 JavaDocs <a class="header-anchor" href="#_2-1-配置文件与-javadocs" aria-label="Permalink to &quot;2-1 配置文件与 JavaDocs&quot;">​</a></h1><p>欢迎回来！希望你的「Hello World」项目运行顺利。</p><h2 id="什么是配置文件" tabindex="-1">什么是配置文件 <a class="header-anchor" href="#什么是配置文件" aria-label="Permalink to &quot;什么是配置文件&quot;">​</a></h2><p>现在我们的插件还只能读取我们预先设定好的数据，如果服主想要输出「Hello Ugly World」呢？如果每次都要修改代码重新编译，未免太麻烦了吧！</p><p>于是，配置文件出现了。</p><p><strong>配置文件</strong>（Config），顾名思义，是一种「设置」，里面记录了许多内容。</p><p>配置文件由服主修改，插件读取，这样就不必修改插件的代码了。</p><h2 id="yaml-格式" tabindex="-1">YAML 格式 <a class="header-anchor" href="#yaml-格式" aria-label="Permalink to &quot;YAML 格式&quot;">​</a></h2><h3 id="像字典一样" tabindex="-1">像字典一样 <a class="header-anchor" href="#像字典一样" aria-label="Permalink to &quot;像字典一样&quot;">​</a></h3><p>配置文件都是 YAML 格式，类似于这样：</p><div class="language-yaml"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">key</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">value</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">key2</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">value2</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">key3</span><span style="color:var(--shiki-token-keyword);">:</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  </span><span style="color:var(--shiki-token-keyword);">key3-1</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">2333</span></span></code></pre></div><p>我们说过 YAML 就像字典，那么字典中的一项是不是可以指向另一个字典啊？<code>key3-1</code> 就是一个例子。它是嵌套的一个字典，这叫做<strong>子键</strong>。子键下面还可以有子键的子键……就是这样。</p><p>我们注意到 <code>key3-1</code> 的前面有两个空格，这叫<strong>缩进</strong>（Indent），如果没有这个缩进，YAML 就不知道这是 <code>key3</code> 的一个子键还是一个独立的键了。因此缩进不能去掉。</p><p>按照规范，YAML 中每进入下一级，就要使用两个空格进行缩进。如果是子键的子键，就要空 4 格，子键的子键的子键就空 6 格，以此类推。</p><h3 id="字典中都有些什么" tabindex="-1">字典中都有些什么？ <a class="header-anchor" href="#字典中都有些什么" aria-label="Permalink to &quot;字典中都有些什么？&quot;">​</a></h3><p>在 YAML 的「字典」中，冒号右边并不是什么都可以放的。实际上，YAML 中能放的东西很有限：</p><ul><li>一个数字</li><li>一段文本</li><li>其它的字典</li><li>列表</li><li>一个逻辑值（<code>true</code> 或 <code>false</code>，真或假）</li></ul><p>由于数字也可以被认为是文本，因此 YAML 采用<strong>特殊优先</strong>原则，也就是，先看看能不能认为它是个数字，如果能，就认为是数字，否则认为是文本。</p><div class="language-yaml"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">number</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">123456789</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">text-no-quote</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">这是文本</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">text-quote</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">&quot;123456789&quot;</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">bool</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">true</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">list</span><span style="color:var(--shiki-token-keyword);">:</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  - </span><span style="color:var(--shiki-token-string-expression);">&quot;一个文本&quot;</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  - </span><span style="color:var(--shiki-token-constant);">12345</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  - </span><span style="color:var(--shiki-token-constant);">true</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  - </span><span style="color:var(--shiki-token-string-expression);">其它的文本</span></span></code></pre></div><p>有关 YAML 的详细语法，可参见 <a href="https://www.runoob.com/w3cnote/yaml-intro.html" target="_blank" rel="noreferrer">菜鸟教程上有关 YAML 的内容</a>。</p><p>采用 YAML 并非因为它的效率或者可读性，而是为了简单的配置方式，正因如此，YAML 适合人类修改，机器读取。</p><p><em>实际上<strong>易于修改</strong>是一个谎言，YAML 采用严格的缩进结构，据不完全统计，超过 98% 的 YAML 配置文件错误都是缩进不当导致的。</em></p><h2 id="默认的-config-yml" tabindex="-1">默认的 <code>config.yml</code> <a class="header-anchor" href="#默认的-config-yml" aria-label="Permalink to &quot;默认的 \`config.yml\`&quot;">​</a></h2><p>Bukkit 为每个插件提供了一个默认配置文件，要使用它，只需要在 <code>src</code> 下创建 <code>config.yml</code>，并在代码中写上：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-function);">saveDefaultConfig()</span><span style="color:var(--shiki-color-text);">;</span></span></code></pre></div><p>这个方法会帮我们保存默认的配置文件，也就是 <code>config.yml</code>。</p><p>Bukkit 很聪明，这个方法会自己查看，如果有了 <code>config.yml</code> 就不进行操作，如果没有就复制一份。</p><p>关于读取，可以通过调用 <code>getConfig</code> 方法获得这个文件的对象（面向对象！）并将它保存在内存的某个地方：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">FileConfiguration</span><span style="color:var(--shiki-color-text);"> config </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">getConfig()</span><span style="color:var(--shiki-color-text);">;</span></span></code></pre></div><p>这里出现了新的 Java 语法。</p><p>这条语句是<strong>赋值</strong>语句，用于将一个变量「设定」为一个对象。</p><p>使用变量有<strong>声明</strong>和<strong>赋值</strong>两步操作，不过它们可以一起用。</p><p>声明的语法：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-color-text);">类型 标识符;</span></span></code></pre></div><p>赋值的语法：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-color-text);">标识符 </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> 右边的值;</span></span></code></pre></div><p>可以看到，声明时需要指定类型，后面赋值和使用时就不需要了。</p><p>一个变量只能声明一次，但可以多次赋值（<code>final</code> 除外）。</p><p>你可以把变量认为是一个小盒子，里面可以装东西。上面这条语句相当于指示 Java 在内存里申请一个盒子用来存放数据。在创建盒子时，Java 需要知道里面要装什么东西，不然就可能出现放不下的问题。</p><p>在这里，由于 <code>getConfig</code> 返回的值是 <code>FileConfiguration</code> 类型，我们也需要使用对应的类进行「盛装」。那我是怎么知道这一点的呢？别急，我们在后面就会看到。</p><h2 id="操作配置文件" tabindex="-1">操作配置文件 <a class="header-anchor" href="#操作配置文件" aria-label="Permalink to &quot;操作配置文件&quot;">​</a></h2><p>现在我们得到了 <code>FileConfiguration</code> 的一个实例，这个类是由 Bukkit 提供的，可以使用一些方法进行操作它。最常用的是 <code>get</code> 和 <code>set</code> 方法及其变种。</p><h3 id="如何使用-javadocs" tabindex="-1">如何使用 JavaDocs <a class="header-anchor" href="#如何使用-javadocs" aria-label="Permalink to &quot;如何使用 JavaDocs&quot;">​</a></h3><p>且慢，现在我是可以把使用方法告诉你，但将来如果你还需要知道其它类的方法，怎么办呢？另外，Bukkit 也不是我编写的，我是怎么知道的呢？</p><p>其实很简单，Spigot 已经把这些信息都写好了，我们只需要去查就可以了。这种资料叫做<strong>文档</strong>（Documentation），是给人类读的而不是给 Java 执行的。</p><p>Spigot 使用一种叫做 JavaDoc 的工具来生成文档，生成的文档已经发布到了 Spigot 的官网上。由于 Spigot 的官网比较慢，而且还不能看以前的版本，这可不行啊！因此，我把 Paper 的文档链接交给你：</p><p><a href="https://papermc.io/javadocs/paper/1.16/overview-summary.html" target="_blank" rel="noreferrer">https://papermc.io/javadocs/paper/1.16/overview-summary.html</a></p><p>这里就是 Paper 的 JavaDocs。Paper 是基于 Spigot 改进而来的（我们似乎说过这个？），因此 Paper 的文档中也具有 Bukkit API 的全部介绍。</p><p>那我们要怎么使用它呢？首先打开上面那个网址，右上角有一个「搜索」栏，在那里，你就可以搜索类了。不仅如此，JavaDocs 还可以搜索方法和变量呢！太聪明了~</p><p><img src="https://s2.loli.net/2022/04/15/sSOXjLeUodPtKDn.png" alt="JDOC.png"></p><p>那么我们现在就来试试吧！首先我们知道，<code>FileConfiguration</code> 类是我们需要找的类，那么我们搜索它……（注意大小写！）</p><p><img src="https://s2.loli.net/2022/04/15/TfdFKmk48BXZoaI.png" alt="SEARCH.png"></p><p>呃……好多结果啊，但由于我们找的是类，因此我们要看「Types」。下面的「Members」表示各个类具有的方法和变量，我们不需要管。</p><p><em>类在 Java 中被称为 Class，但在英语中，「类型」一词的正确翻译是 Type，所以搜索结果中也使用了 Type 而非 Class。</em></p><p><code>FileConfigurationOptions</code> 显然不是我们需要的类，那么我们忽略掉，就只剩下一个了，点击一下，打开之后像这样：</p><p><img src="https://s2.loli.net/2022/04/15/q9DLYQBH3TcXOrb.png" alt="CLAZZ1.png"></p><p><img src="https://s2.loli.net/2022/04/15/T5RaIdqQc3ixtnS.png" alt="CLAZZ2.png"></p><p>上面有两张图，我给你标出来了几个部分。</p><p>紫色区域是包名，这个你应该知道是什么吧？</p><p>蓝色区域是<strong>继承关系</strong>，可以告诉你当前的这个类继承了哪一个类，而那个类又继承了哪一个类等等。</p><p>棕色区域是<strong>类签名</strong>，那什么是签名呢？</p><p><strong>签名</strong>（Signature）就是去掉 <code>{}</code> 之外的部分。</p><p>我们定义类时，是这么定义的：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">class</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">SomeClass</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">extends</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">XXXXClass</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-comment);">// ... 一堆东西</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">};</span></span></code></pre></div><p>去掉后面的 <code>{}</code> 以及里面的东西，剩下的就叫签名。上面这个类的签名就是：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">class</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">SomeClass</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">extends</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">XXXXClass</span></span></code></pre></div><p>签名能够用于识别一个类。不过下面很快我们就要看到它的另一个重要用途。</p><hr><p>现在我们接着往下看。「Field Summary」是什么东西啊？</p><p>「Field」是类的<strong>成员变量</strong>，也叫实例变量，比如，如果一条狗是一个对象，身高就是它的一个「Field」，如果一个插件是一个对象，版本可能就是它的一个「Field」。总之，<strong>成员变量就是属于一个对象的变量</strong>。访问成员变量和访问成员方法一样，都是使用点（<code>.</code>），这个点同样表示「的」。</p><p>这里值得说明的一点是，变量本身也是一个对象，它也有自己的成员变量，所以可能会出现这样的情况：「我的邻居家的亲戚家养的狗的牙齿的长度」，这当然是没问题的。很简单？确实也没什么难的嘛……</p><p>那么「Field Summary」提供的信息就很明显了吧，它提供的是变量名而没有显示变量的类型，用你的鼠标单击变量名就能查看它的类型了。</p><p>不对！这里为什么还有「Fields inherited from」这样的东西？这是什么意思？</p><p>嗯，我们之前讲到过<strong>继承</strong>，「Inherite」就是继承的意思。图中的信息表示，<code>MemoryConfiguration</code> 具有两个叫做 <code>defaults</code> 和 <code>options</code> 的成员变量，<code>FileConfiguration</code> 继承了它，因此也具有了这两个成员变量。而 <code>MemoryConfiguration</code> 继承了 <code>MemorySection</code>，<code>MemorySection</code> 具有一个名为 <code>map</code> 的成员变量，它将这个变量交给<code>MemoryConfiguration</code>，<code>MemoryConfiguration</code> 再将它交给 <code>FileConfiguration</code>，这样 <code>FileConfiguration</code> 中就也有了 <code>map</code> 变量。</p><p>说了这么多，继承来的东西无非就是：「你有的我都有，你没有的我也有。」</p><hr><p>我们接着往下看，下面出现了「Constructor Summary」，这是<strong>构造方法</strong>。</p><p>构造方法是一个特殊的方法，它用<strong>创建一个对象</strong>。构造方法在定义时无法指定返回值。</p><p>我们说过，一般的成员方法都要通过 <code>&lt;对象&gt;.方法</code> 进行调用，那构造方法怎么办呢？我们还没有对象呢！</p><p>这就不得不说到 <code>new</code> 关键字了，<code>new</code> 用于指示 Java 创建一个对象。语法如下：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">new</span><span style="color:var(--shiki-color-text);"> 类型(参数);</span></span></code></pre></div><p>构造方法的名称和类名称完全一样，返回值就是一个新的对象（它叫<strong>构造</strong>方法嘛），可以交给变量存储起来。</p><p>现在再看「Constructor Summary」，就很明白了吧？它告诉我们，要构造一个新的 <code>FileConfiguration</code>，可以通过调用这两个方法之一。</p><p>不过等等啊，这两个方法的名字为什么完全一样呢？</p><p>那当然了，构造方法的名字必须和类名一样嘛~</p><p>那为什么要成为两个方法呢？Java 怎么知道我们要调用哪个方法呢？</p><p>事实上，Java 在调用方法时，并不是使用方法名进行判断的，而是使用<strong>方法签名</strong>进行判断的。</p><p>按照上面类签名的思路，我们把方法的大括号（方法体）去掉：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">void</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">SomeMethod(</span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-token-function);"> arg1</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-token-function);"> </span><span style="color:var(--shiki-token-keyword);">int</span><span style="color:var(--shiki-token-function);"> arg2)</span></span></code></pre></div><p>你看，不只有方法名嘛！参数列表，返回值（构造方法无法直接指定返回值），访问修饰符，只要有一个不一样，也是可以区分的嘛！</p><p>因此，我们完全可以编写很多不同的方法，以处理不同的参数，调用方法的人也很方便，无论怎么调用，名字都一样，多方便啊！</p><p><em>以后我向你展示某个方法时，如未特别注明，给你看的都是方法签名，这也是大多数开发人员的习惯。</em></p><p>现在我们再看这两个 <code>FileConfiguration</code> 的构造方法，就很明白了吧？一个不接受参数，一个接受一个类型为 <code>Configuration</code> 的参数。</p><hr><p>最后是「Method Summary」，看到这里你应该已经能够独自阅读了吧？</p><p>「Modifier and Type」表示修饰符和返回值，「Method」表示方法名和参数列表，「Description」是 Bukkit 开发人员为我们写的注释。</p><p>修饰符由访问修饰符和其它修饰符构成。</p><p>说了那么久的访问修饰符，到底啥是访问修饰符捏？</p><p>访问修饰符用于控制一个<strong>变量</strong>、<strong>方法</strong>或<strong>类</strong>是否能够被外部访问，有且仅有三个访问修饰符：</p><ul><li><code>public</code>：这个类、方法或变量可以在任何地方被使用</li><li><code>protected</code>：由于不能修饰外部类，因此它表示该方法或变量只能被子类（继承者）使用，「外族人不得擅入」！</li><li><code>private</code>：由于不能修饰外部类，因此它表示该方法或变量只能被自己（当前类）使用，子类和其它类都不能使用</li></ul><p>另外还有几个其它修饰符：</p><ul><li><code>abstract</code>：不能修饰变量，修饰方法时表示该方法没有被完整实现（只是一个空壳），不能被调用，如果一个类中有 <code>abstract</code> 的方法，这个类也要 <code>abstract</code>；如果要实例化一个 <code>abstract</code> 的类，必须继承它并重写（<code>@Override</code>）那些 <code>abstract</code> 方法（完成先辈未竟的事业）</li><li><code>final</code>：不能与 <code>abstract</code> 一起用，修饰类时表示该类不能被继承，修饰方法时表示子类不可以重写该方法，修饰成员变量时表示该变量一经创建不可修改</li><li><code>static</code>：不能修饰外部类，修饰方法时表示该方法不属于哪个对象，而属于整个类共有；修饰变量时表示该变量不属于哪个对象，属于整个类共有，要调用静态方法和变量，不使用 <code>&lt;对象名&gt;.&lt;方法或变量的名字&gt;</code>，而使用 <code>&lt;类名&gt;.&lt;方法或变量的名字&gt;</code></li></ul><p>这里简单了解即可。在 JavaDocs 中，<code>public</code> 会被省略掉以便查看。</p><hr><p>现在我们终于可以回到正题上来了！我们来找找 <code>set</code> 和 <code>get</code> 方法……注意，我们要找的方法可能不只是叫 <code>get</code> 和 <code>set</code>，它们的变种可能有类似的名字。</p><p>咦？怎么没有？</p><p>啊哈，找到了，它不在「Method Summary」中，而在「Methods inherited from interface org.bukkit.configuration.ConfigurationSection」中。</p><p><img src="https://s2.loli.net/2022/04/15/drJB4WIk8f9DG3H.png" alt="GETSET.png"></p><p>可以看到这里有非常多的 <code>getXXX</code> 版本用于取得不同类型的数据，而只有一个 <code>set</code> 方法，这一个 <code>set</code> 就可以对付所有情况了。点击上面的方法可以获得它的详细签名。</p><p>好啦！到这里，你就会使用 JavaDocs 了，以后，我们还会经常见到它的~</p><h3 id="yaml-寻址" tabindex="-1">YAML 寻址 <a class="header-anchor" href="#yaml-寻址" aria-label="Permalink to &quot;YAML 寻址&quot;">​</a></h3><p>假设有这么一份配置文件：</p><div class="language-yaml"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">mysql</span><span style="color:var(--shiki-token-keyword);">:</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  </span><span style="color:var(--shiki-token-keyword);">use-mysql</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">true</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  </span><span style="color:var(--shiki-token-keyword);">host</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">localhost</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  </span><span style="color:var(--shiki-token-keyword);">auth-data</span><span style="color:var(--shiki-token-keyword);">:</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-keyword);">password</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">123456</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">auto-login-delay</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">300</span></span></code></pre></div><p>我们怎么读取其中的值呢？</p><p>要知道怎么读取其中的值，我们需要知道每一个键的「地址」，找出这个键的过程就叫<strong>寻址</strong>。</p><p>YAML 的寻址规则很简单：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-color-text);">&lt;上一个键&gt;.&lt;子键名&gt;.&lt;子键名&gt;</span></span></code></pre></div><p>譬如，上面 <code>password</code> 的地址就是：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-color-text);">mysql.auth-data.password</span></span></code></pre></div><p>而 <code>host</code> 的地址就是：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-color-text);">mysql.host</span></span></code></pre></div><p><code>auto-login-delay</code> 的地址就是：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-color-text);">auto-login-delay</span></span></code></pre></div><p>这样我们就能确定各个键的地址了。知道这一点有啥用捏？</p><h3 id="直接读取" tabindex="-1">直接读取 <a class="header-anchor" href="#直接读取" aria-label="Permalink to &quot;直接读取&quot;">​</a></h3><p>上面我们看到了那么多的 <code>get</code> 以及一个万能的 <code>set</code>，要让它们工作，我们需要给它们提供参数。查询 JavaDocs，我们查到了 <code>get</code> 的方法签名：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-color-text);">@</span><span style="color:var(--shiki-token-keyword);">Nullable</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">Object</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">get(@</span><span style="color:var(--shiki-token-keyword);">NotNull</span><span style="color:var(--shiki-token-function);"> </span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-token-function);"> path)</span><span style="color:var(--shiki-color-text);">;</span></span></code></pre></div><p><code>@Nullable</code> 表示返回值可能是 <code>null</code>，<code>@NotNull</code> 则相反，表示这个值不能为 <code>null</code>，去掉它们也不影响阅读，去掉它们之后，方法签名终于出现在我们的面前：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">Object</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">get(</span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-token-function);"> path)</span><span style="color:var(--shiki-color-text);">;</span></span></code></pre></div><p>返回值是 <code>Object</code>，需要提供一个参数：<code>String</code> 类型，名叫 <code>path</code>。</p><p>再看看 Bukkit 的说明：「Gets the requested Object by path.」</p><p>嗯，我们没找错地方。这里的 <code>path</code> 就是地址。</p><p>因此我们要读取上面配置文件中的 <code>password</code>，用 Java 就该这么写：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">FileConfiguration</span><span style="color:var(--shiki-color-text);"> config </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">getConfig()</span><span style="color:var(--shiki-color-text);">;</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-color-text);"> password </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> (String) </span><span style="color:var(--shiki-token-constant);">config</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">get</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-string-expression);">&quot;mysql.auth-data.password&quot;</span><span style="color:var(--shiki-color-text);">);</span></span></code></pre></div><p>这里出现了一点新东西：<code>(String)</code>，这表示「强制转换」。因为 <code>get</code> 方法不是针对字符串设计的，它返回 <code>Object</code> 类，这个类是任何类的父类。</p><p>但是这样可不行啊，明明是一个 <code>String</code>，却只能当 <code>Object</code> 用，太憋屈了！在这种情况（我们比 Java 更清楚这是什么）下，我们可以使用<strong>强制类型转换</strong>（Cast）尝试进行转换。<code>(String)</code> 的作用正是如此。Java 会先判断是否可以转换，如果可以，它就勉为其难地转换；如果不行，已经火冒三丈的 Java 就会抛出一个错误并结束当前线程。这样做太危险了！</p><h3 id="安全读取" tabindex="-1">安全读取 <a class="header-anchor" href="#安全读取" aria-label="Permalink to &quot;安全读取&quot;">​</a></h3><p>实际上，我们可以使用 <code>get</code> 的姐妹方法 <code>getString</code> 来获得 <code>String</code> 的结果，它会帮我们「温柔地」完成转换，即使转换不了，也最多只会返回一个 <code>null</code>。</p><p>这样很好，但我们还不满足。即使返回 <code>null</code> 也可能引发<s>喜闻乐见的</s> <code>NullPointerException</code>，<code>getString</code> 想到了这个情况，因此用同一个名字，创建了下面这个方法：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">getString(</span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-token-function);"> path</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-token-function);"> </span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-token-function);"> def)</span></span></code></pre></div><p>第二个参数 <code>def</code> 指定一个默认值，当 <code>getString</code> 无法转换时将返回 <code>def</code> 指定的值，而不是 <code>null</code>。</p><p>上面那个配置文件示例中还有数字，这要怎么获取呢？</p><p>整数在 Java 中的类型是 <code>Integer</code> 或者 <code>int</code>，因此在 <code>FileConfiguration</code> 中可以通过以下方法获得：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">int</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">getInt(</span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-token-function);"> path</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-token-function);"> </span><span style="color:var(--shiki-token-keyword);">int</span><span style="color:var(--shiki-token-function);"> def)</span></span></code></pre></div><p>同样，逻辑（<code>true</code> 和 <code>false</code>）可以使用：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">boolean</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">getBoolean(</span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-token-function);"> path</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-token-function);"> </span><span style="color:var(--shiki-token-keyword);">boolean</span><span style="color:var(--shiki-token-function);"> def)</span></span></code></pre></div><p>现在我们就把各个值都读出来吧！</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">boolean</span><span style="color:var(--shiki-color-text);"> useMySQL </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">config</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">getBoolean</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-string-expression);">&quot;mysql.use-mysql&quot;</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">false</span><span style="color:var(--shiki-color-text);">);</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-color-text);"> host </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">config</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">getString</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-string-expression);">&quot;mysql.host&quot;</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">&quot;localhost&quot;</span><span style="color:var(--shiki-color-text);">);</span></span>
<span class="line"><span style="color:var(--shiki-token-comment);">// 这是注释，一行有效</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-color-text);"> password </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">config</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">getString</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-string-expression);">&quot;mysql.auth-data.password&quot;</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">&quot;&quot;</span><span style="color:var(--shiki-color-text);">);</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-color-text);"> autoLoginDelay </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">config</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">getInt</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-string-expression);">&quot;auto-login-delay&quot;</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">300</span><span style="color:var(--shiki-color-text);">);</span></span></code></pre></div><p>怎么样？很简单吧？实际上我是为了介绍 Java 才说了这么多内容，只谈配置文件的话，没什么内容的。</p><p>这里我再多说一点，<code>getXXXX</code> 方法可以 <code>get</code> 很多类型，比如 <code>ItemStack</code>（表示一个物品堆），<code>Color</code>（表示一种颜色）等等，这是 Bukkit 针对游戏进行的优化，将来我们也许会见到它们的。如果实在等不及，那就去查查 <code>JavaDocs</code> 看看它们怎么用吧！</p><h3 id="写入" tabindex="-1">写入 <a class="header-anchor" href="#写入" aria-label="Permalink to &quot;写入&quot;">​</a></h3><p>写入只有一个 <code>set</code> 方法，我们来看看它的签名：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">void</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">set(</span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-token-function);"> path</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-token-function);"> </span><span style="color:var(--shiki-token-keyword);">Object</span><span style="color:var(--shiki-token-function);"> value)</span></span></code></pre></div><p>没有返回值，提供一个 <code>path</code> 和一个 <code>value</code>。</p><p>那么我们像上面读取这些值一样，演示一下设置的方法：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-constant);">config</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">set</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-string-expression);">&quot;mysql.use-mysql&quot;</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">true</span><span style="color:var(--shiki-color-text);">);</span></span>
<span class="line"><span style="color:var(--shiki-token-constant);">config</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">set</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-string-expression);">&quot;mysql.auth-data.password&quot;</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">&quot;123456&quot;</span><span style="color:var(--shiki-color-text);">);</span></span>
<span class="line"><span style="color:var(--shiki-token-constant);">config</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">set</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-string-expression);">&quot;mysql.host&quot;</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">&quot;127.0.0.1&quot;</span><span style="color:var(--shiki-color-text);">);</span></span>
<span class="line"><span style="color:var(--shiki-token-constant);">config</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">set</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-string-expression);">&quot;auto-login-delay&quot;</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">1000</span><span style="color:var(--shiki-color-text);">);</span></span></code></pre></div><p>这样很简单吧？</p><p>等等！为什么第二个参数是 <code>Object</code>，你却能把 <code>String</code>、<code>int</code> 和 <code>boolean</code> 给它们？为什么这里不需要 <code>(Object) &quot;123456&quot;</code> 这样的操作？</p><p>首先，你回答我一个问题：</p><p><strong><code>String</code> 是不是一种 <code>Object</code>？</strong></p><p>当然是啦！</p><p><strong>那，<code>String</code> 既然是一种 <code>Object</code>，为什么 Java 不能把它当作 <code>Object</code> 看待呢</strong>？</p><p>……可是，你说，上面那个 <code>get</code>……哦！我明白了！因为 <code>get</code>返回的是 <code>Object</code>，<code>Object</code> 不一定是一种 <code>String</code>，对不对？</p><p>是的。从子类转向父类没有风险，Java 会毫不犹豫地自动完成，而从父类转向子类有风险，需要我们亲自指示 Java 这样做。</p><p>写入之后还没完，我们只修改了内存中的一个副本，要将修改写入硬盘，还要保存：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-function);">saveConfig()</span><span style="color:var(--shiki-color-text);">;</span></span></code></pre></div><p>这个方法是 <code>JavaPlugin</code> 的一个方法，Bukkit 自动帮我们完成写入工作。<strong>记住：只有保存后，文件才会被真正写入硬盘</strong>！</p><p>读取时则不需要保存，因为读取没有修改那个副本。</p><h3 id="删除" tabindex="-1">删除 <a class="header-anchor" href="#删除" aria-label="Permalink to &quot;删除&quot;">​</a></h3><p>如果要你删除一个键，已经学过 JavaDocs 的你会想到什么？</p><p>唔……有没有 <code>delete</code> 方法？你看，<code>set</code> 可以设置任何键，应该有这样的 <code>delete</code> 吧？</p><p>很遗憾，没有。</p><p>啥？</p><p>是的，没有。因为 YAML 不需要额外的一个方法，<code>set</code> 方法就可以删除键了。</p><p><strong>YAML 中所有不存在的键，它的值都是 <code>null</code>。</strong></p><p>利用这个特点，要删除键，我们只需要把它的值设为 <code>null</code> 就可以了，保存时 Bukkit 会忽略为 <code>null</code> 的键。</p><hr><p>哇！这一节真长！不过想想也是，与其说这是配置文件教程，不如说这是 Java 教程啦。</p><p>加油！我敢说，最难的部分已经过去了！</p>`,179),l=[t];function p(i,r,c,k,d,y){return o(),a("div",null,l)}const u=s(e,[["render",p]]);export{h as __pageData,u as default};
