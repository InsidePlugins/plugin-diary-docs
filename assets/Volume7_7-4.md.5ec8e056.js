import{_ as s,o,c as n,S as a}from"./chunks/framework.7f03344f.js";const v=JSON.parse('{"title":"7-4 线程安全性","description":"","frontmatter":{},"headers":[],"relativePath":"Volume7/7-4.md","filePath":"docs/Volume7/7-4.md","lastUpdated":1698403164000}'),t={name:"Volume7/7-4.md"},e=a(`<h1 id="_7-4-线程安全性" tabindex="-1">7-4 线程安全性 <a class="header-anchor" href="#_7-4-线程安全性" aria-label="Permalink to &quot;7-4 线程安全性&quot;">​</a></h1><p>Bukkit 服务器在运行时拥有数量庞大的线程，多线程使得程序从<strong>串行</strong>变为<strong>并发</strong>，合理利用了 CPU 的管道机制和多核性能。</p><div class="danger custom-block"><p class="custom-block-title"><img src="data:image/svg+xml,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; viewBox=&#39;0 0 16 16&#39; transform=&#39;scale(0.6)&#39; fill=&#39;%23fff&#39;%3E%3Cpath d=&#39;M10 14C10 15.1 9.1 16 8 16 6.9 16 6 15.1 6 14 6 12.9 6.9 12 8 12 9.1 12 10 12.9 10 14Z&#39;/%3E%3Cpath d=&#39;M10 1.6C10 1.2 9.8 0.9 9.6 0.7 9.2 0.3 8.6 0 8 0 7.4 0 6.8 0.2 6.5 0.6 6.2 0.9 6 1.2 6 1.6 6 1.7 6 1.8 6 1.9L6.8 9.6C6.9 9.9 7 10.1 7.2 10.2 7.4 10.4 7.7 10.5 8 10.5 8.3 10.5 8.6 10.4 8.8 10.3 9 10.1 9.1 9.9 9.2 9.6L10 1.9C10 1.8 10 1.7 10 1.6Z&#39;/%3E%3C/svg%3E" style="background-color:#DA0B50;clip-path:circle();" width="24px" height="24px"> <strong>误区警示</strong></p><p>很多人认为，多线程只不过是 CPU 在多个线程之间切换，因此并不能提升性能，<strong>这种观点是错误的</strong>。</p><ol><li>首先，一个 CPU 可能有很多内核，它们可以同时进行处理。</li><li>其次，CPU 解释机器指令（32 位或 64 位）时采用管道机制，即当前指令还在执行时，就开始解释下一条乃至再下一条指令，也可以实现并行。</li><li>最后，涉及到磁盘、网卡等设备的外部 IO 操作时，有些电脑使用 DMA 技术，CPU 就可以不必参与数据读取的全过程，这时候 CPU 如果闲着还不如把处理能力放在其它的线程上。</li><li>最重要的，<strong>多线程使得多任务成为可能</strong>，这对于非阻塞的事件驱动系统（如 Bukkit）是<strong>相当重要的</strong>，如果不能进行多任务，就会出现类似于当一个玩家移动时，其它玩家移动不了的情况。</li></ol><p>所以，无论多线程是否能够带来性能上的提升，多线程都是必要的。而且事实证明，合理的多线程确实提升了速度。</p></div><p>Bukkit 中实现多线程的方法很多，但最常用的是重写 <code>BukkitRunnable</code> 类并进行 <code>runTask</code>、<code>runTaskLater</code>、<code>runTaskAsynchronously</code>、<code>runTaskLaterAsynchoronously</code> 等等。这个你应该已经见到过很多很多很多次了。因此，我不准备再讲一遍如何实现多线程了。</p><p>我们今天要讨论的问题更重要：<strong>线程安全</strong>。</p><h2 id="什么是线程安全" tabindex="-1">什么是线程安全 <a class="header-anchor" href="#什么是线程安全" aria-label="Permalink to &quot;什么是线程安全&quot;">​</a></h2><p><em>以下内容摘自维基百科。</em></p><blockquote><p>线程安全是程式设计中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p></blockquote><p>也就是说，<strong>多个</strong>线程使用<strong>同一个</strong>变量，而不会导致冲突。</p><p>说得形象一点，这就像几个人共用一个洗手间。</p><ul><li>线程安全：先到的人（线程）进去在里面把门关上，其它人（线程）需要等待</li><li>线程不安全：洗手间没有门，所有人（线程）一哄而上，后果……</li></ul><p>一般情况下，多个线程访问同一个数据是<strong>不安全的</strong>。几个线程一起写数据，就可能会出现未知的后果。</p><p>要使得线程安全，我们就需要考虑不安全的条件：</p><ul><li>多个线程<strong>共享一个</strong>数据变量</li><li>这些线程同时对数据变量进行操作</li></ul><p>那我们只需要破坏这两个条件之一就可以了。事实上在 Java 的世界中，已经有了这样的方法。</p><ul><li>破坏第一个条件：<strong>为每个线程分配单独的数据</strong>（各用各的，谁也别抢， HarmonyAuth SMART 中 <code>IDataManager</code> 每次重新创建就是用的这种方法）</li><li>破坏第二个条件：<strong>同步锁</strong>（一次一个，其它等着，HarmonyAuth SMART 中 <code>sti</code> 和 <code>cli</code> 方法前面的 <code>synchronized</code> 就是这样做的）</li></ul><p>下面我们依次介绍这两种方法。</p><h2 id="为每个线程分配单独的数据" tabindex="-1">为每个线程分配单独的数据 <a class="header-anchor" href="#为每个线程分配单独的数据" aria-label="Permalink to &quot;为每个线程分配单独的数据&quot;">​</a></h2><p>这个方法适用于那些<strong>并不真正需要共享的</strong>数据。例如 <code>IDataManager</code> 这样的工具对象，或者<strong>需要读取但不需要写入</strong>的对象。</p><p>在一个线程开始时（通常是 <code>BukkitRunnable</code> 中的 <code>run</code> 方法开头），对于可以单独分配的数据，应该<strong>立即创建或复制</strong>。</p><p>虽然分配单独的数据很简单，也不能做到数据共享，但它确实能够解决大部分不需要共享的数据的多线程访问的问题。</p><h2 id="同步锁" tabindex="-1">同步锁 <a class="header-anchor" href="#同步锁" aria-label="Permalink to &quot;同步锁&quot;">​</a></h2><p>在一个方法前面加上 <code>synchronized</code> 就可以<strong>一次只允许一个线程调用该方法</strong>，将操作共享数据的方法放在里面就可以了。</p><p>例如：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">private</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">static</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">List</span><span style="color:var(--shiki-color-text);">&lt;</span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-color-text);">&gt; someList </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">new</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">ArrayList</span><span style="color:var(--shiki-color-text);">&lt;&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">synchronized</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">get(</span><span style="color:var(--shiki-token-keyword);">int</span><span style="color:var(--shiki-token-function);"> index)</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-keyword);">return</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">someList</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">get</span><span style="color:var(--shiki-color-text);">(index);</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">synchronized</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">void</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">set(</span><span style="color:var(--shiki-token-keyword);">int</span><span style="color:var(--shiki-token-function);"> index</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-token-function);"> </span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-token-function);"> s)</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-constant);">someList</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">set</span><span style="color:var(--shiki-color-text);">(index</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> s);</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">synchronized</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">void</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">add(</span><span style="color:var(--shiki-token-keyword);">String</span><span style="color:var(--shiki-token-function);"> s)</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-constant);">someList</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">add</span><span style="color:var(--shiki-color-text);">(s);</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">}</span></span></code></pre></div><p>这样 <code>someList</code> 得到保护，这三个同步方法（<code>get</code>、<code>set</code> 和 <code>add</code>）保证一次只能有一个线程读写 <code>someList</code>。</p><p>上面的方法很麻烦，而且还容易忘掉这样写，幸运的是，有人已经为我们完成了这项工作，这就是第三种方法……</p><h2 id="使用线程安全的实现" tabindex="-1">使用线程安全的实现 <a class="header-anchor" href="#使用线程安全的实现" aria-label="Permalink to &quot;使用线程安全的实现&quot;">​</a></h2><p>有些类在设计时就已经考虑到了多线程的情况，这些类通常可以处理多个线程同时访问（实际上是内部用了同步锁或者更高级的技巧）。</p><p><code>ArrayList</code> 是我们常用的一个 <code>List</code> 的实现，但很遗憾，虽然它很快，但它<strong>不是线程安全的</strong>。</p><p>与 <code>ArrayList</code> 相比，另一个 <code>List</code> 的实现 <code>Vector</code> 具有和 <code>ArrayList</code> 一样的功能，但它<strong>是线程安全的</strong>。这也就是说，「放心地让多个线程去读写它吧，没有问题的」。<code>Vector</code> <strong>内部已经处理了多线程的情况</strong>。我们只需要 <code>new</code>，之后就可以在多个线程里面同时对它进行 <code>set</code>、<code>add</code> 等等操作了，不需要同步锁什么的，是不是很方便？</p><p>下面列出了一些常见的，非线程安全类的替代品：</p><table><thead><tr><th>非线程安全的类</th><th>线程安全的替代品</th></tr></thead><tbody><tr><td><code>ArrayList</code>（速度很快）</td><td><code>Vector</code>（速度较慢）<br><code>Stack</code>（速度较慢）</td></tr><tr><td><code>HashMap</code>（速度很快）</td><td><code>ConcurrentHashMap</code>（并发，速度略慢）<br><code>Hashtable</code>（速度较慢）</td></tr><tr><td><code>StringBuilder</code>（速度较快）</td><td><code>StringBuffer</code>（速度较慢）</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title"><img src="data:image/svg+xml,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; viewBox=&#39;0 0 1028 1024&#39; transform=&#39;scale(0.6)&#39; fill=&#39;%23fff&#39;%3E%3Cpath d=&#39;M1018.319924 112.117535q4.093748 9.210934 6.652341 21.492179t2.558593 25.585928-5.117186 26.609365-16.374994 25.585928q-12.281245 12.281245-22.003898 21.492179t-16.886712 16.374994q-8.187497 8.187497-15.351557 14.32812l-191.382739-191.382739q12.281245-11.257808 29.167958-27.121083t28.144521-25.074209q14.32812-11.257808 29.679676-15.863275t30.191395-4.093748 28.656239 4.605467 24.050772 9.210934q21.492179 11.257808 47.589826 39.402329t40.425766 58.847634zM221.062416 611.554845q6.140623-6.140623 28.656239-29.167958t56.289041-56.80076l74.710909-74.710909 82.898406-82.898406 220.038979-220.038979 191.382739 192.406177-220.038979 220.038979-81.874969 82.898406q-40.937484 39.914047-73.687472 73.175753t-54.242167 54.753885-25.585928 24.562491q-10.234371 9.210934-23.539054 19.445305t-27.632802 16.374994q-14.32812 7.16406-41.960921 17.398431t-57.824197 19.957024-57.312478 16.886712-40.425766 9.210934q-27.632802 3.070311-36.843736-8.187497t-5.117186-37.867173q2.046874-14.32812 9.722653-41.449203t16.374994-56.289041 16.886712-53.730448 13.304682-33.773425q6.140623-14.32812 13.816401-26.097646t22.003898-26.097646z&#39;/%3E%3C/svg%3E" style="background-color:#057E3D;clip-path:circle();" width="24px" height="24px"> <strong>编者注</strong></p><p>原文中，<code>HashMap</code> 的第二个替代品是 <code>HashTable</code>。谨按，Java 标准库中只有 <code>java.util.Hashtable</code>，没有 <code>java.util.HashTable</code>，疑为字母大小写笔误。此处依照 Java 标准库改正。表格内空间较小，故不保留原文。</p></div><p><s>此外，<code>Collections</code> 的 <code>synchronizedCollection</code> 方法可以「复制」一个线程安全的 <code>Collection</code>，注意，这是<strong>复制</strong>（创建一个新的），并不是就地修改。</s></p><p><s><code>List</code> 也是一种 <code>Collection</code>，因此这个方法可以从已有的 <code>List</code> 对象创建一个数据不变的、新的、线程安全的对象。当然了，这样做速度会有所损失。</s></p><div class="tip custom-block"><p class="custom-block-title"><img src="data:image/svg+xml,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; viewBox=&#39;0 0 1028 1024&#39; transform=&#39;scale(0.6)&#39; fill=&#39;%23fff&#39;%3E%3Cpath d=&#39;M1018.319924 112.117535q4.093748 9.210934 6.652341 21.492179t2.558593 25.585928-5.117186 26.609365-16.374994 25.585928q-12.281245 12.281245-22.003898 21.492179t-16.886712 16.374994q-8.187497 8.187497-15.351557 14.32812l-191.382739-191.382739q12.281245-11.257808 29.167958-27.121083t28.144521-25.074209q14.32812-11.257808 29.679676-15.863275t30.191395-4.093748 28.656239 4.605467 24.050772 9.210934q21.492179 11.257808 47.589826 39.402329t40.425766 58.847634zM221.062416 611.554845q6.140623-6.140623 28.656239-29.167958t56.289041-56.80076l74.710909-74.710909 82.898406-82.898406 220.038979-220.038979 191.382739 192.406177-220.038979 220.038979-81.874969 82.898406q-40.937484 39.914047-73.687472 73.175753t-54.242167 54.753885-25.585928 24.562491q-10.234371 9.210934-23.539054 19.445305t-27.632802 16.374994q-14.32812 7.16406-41.960921 17.398431t-57.824197 19.957024-57.312478 16.886712-40.425766 9.210934q-27.632802 3.070311-36.843736-8.187497t-5.117186-37.867173q2.046874-14.32812 9.722653-41.449203t16.374994-56.289041 16.886712-53.730448 13.304682-33.773425q6.140623-14.32812 13.816401-26.097646t22.003898-26.097646z&#39;/%3E%3C/svg%3E" style="background-color:#057E3D;clip-path:circle();" width="24px" height="24px"> <strong>编者注</strong></p><p>原文中，对 <code>synchronizedCollection</code> 方法的介绍有误。该方法并非复制，而是包装。下文依照 Java 官方文档及标准库源代码改正。上方加删除线的两行是原文。</p><p><code>Collections</code> 的 <code>synchronizedCollection</code> 方法可以「包装」一个线程<strong>不</strong>安全的 <code>Collection</code>，使之变得线程安全。注意，这是<strong>包装</strong>，是就地修改。</p><p>比如：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">List</span><span style="color:var(--shiki-color-text);">&lt;</span><span style="color:var(--shiki-token-keyword);">Integer</span><span style="color:var(--shiki-color-text);">&gt; ints </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">new</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">ArrayList</span><span style="color:var(--shiki-color-text);">&lt;&gt;();</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">Collection</span><span style="color:var(--shiki-color-text);">&lt;</span><span style="color:var(--shiki-token-keyword);">Integer</span><span style="color:var(--shiki-color-text);">&gt; wrapper </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">Collections</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">synchronizedCollection</span><span style="color:var(--shiki-color-text);">(ints);</span></span>
<span class="line"><span style="color:var(--shiki-token-constant);">wrapper</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">add</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-constant);">1</span><span style="color:var(--shiki-color-text);">);</span></span>
<span class="line"><span style="color:var(--shiki-token-constant);">wrapper</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">add</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-constant);">2</span><span style="color:var(--shiki-color-text);">);</span></span>
<span class="line"><span style="color:var(--shiki-token-constant);">wrapper</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">add</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-constant);">3</span><span style="color:var(--shiki-color-text);">);</span></span></code></pre></div><p>然后，<code>ints</code> 列表就变成了 [1, 2, 3]，有三个元素，不再是空列表了。对于 <code>wrapper</code> 的操作直接体现在了被包装的 <code>ints</code> 列表上。</p><p>这是因为 <code>synchronizedCollection</code> 方法是根据已有的集合，包装出线程安全的对象。源代码大约是这样的（有删改）：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">static</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">class</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">SynchronizedCollection</span><span style="color:var(--shiki-color-text);">&lt;</span><span style="color:var(--shiki-token-keyword);">E</span><span style="color:var(--shiki-color-text);">&gt; </span><span style="color:var(--shiki-token-keyword);">implements</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">Collection</span><span style="color:var(--shiki-color-text);">&lt;</span><span style="color:var(--shiki-token-keyword);">E</span><span style="color:var(--shiki-color-text);">&gt;</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">Serializable</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-keyword);">final</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">Collection</span><span style="color:var(--shiki-color-text);">&lt;</span><span style="color:var(--shiki-token-keyword);">E</span><span style="color:var(--shiki-color-text);">&gt; c;  </span><span style="color:var(--shiki-token-comment);">// Backing Collection</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-keyword);">final</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">Object</span><span style="color:var(--shiki-color-text);"> mutex;     </span><span style="color:var(--shiki-token-comment);">// Object on which to synchronize</span></span>
<span class="line"></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-function);">SynchronizedCollection</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-keyword);">Collection</span><span style="color:var(--shiki-color-text);">&lt;</span><span style="color:var(--shiki-token-keyword);">E</span><span style="color:var(--shiki-color-text);">&gt; c) {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        </span><span style="color:var(--shiki-token-constant);">this</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-constant);">c</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">Objects</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">requireNonNull</span><span style="color:var(--shiki-color-text);">(c);</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        mutex </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">this</span><span style="color:var(--shiki-color-text);">;</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">boolean</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">add</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-keyword);">E</span><span style="color:var(--shiki-color-text);"> e) {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        </span><span style="color:var(--shiki-token-keyword);">synchronized</span><span style="color:var(--shiki-color-text);"> (mutex) {</span><span style="color:var(--shiki-token-keyword);">return</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">c</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">add</span><span style="color:var(--shiki-color-text);">(e);}</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">boolean</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">remove</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-keyword);">Object</span><span style="color:var(--shiki-color-text);"> o) {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        </span><span style="color:var(--shiki-token-keyword);">synchronized</span><span style="color:var(--shiki-color-text);"> (mutex) {</span><span style="color:var(--shiki-token-keyword);">return</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">c</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">remove</span><span style="color:var(--shiki-color-text);">(o);}</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    }</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">}</span></span></code></pre></div><p>也就是说，<code>SynchronizedCollection</code> 实际上不会存储数据，数据都在原来的 <code>c</code> 集合里（也就是上述的 <code>ints</code> 集合）。添加、删除数据，都调用 <code>c</code> 集合自身的相应方法。只不过调用以前先以 <code>synchronized</code> 给自身上锁，这样，同一时间就只能有一个线程调用这个 <code>SynchronizedCollection</code> 所提供的任何方法。一个线程在 <code>add</code> 时，其余线程既不能 <code>add</code> 也不能 <code>remove</code>。线程安全得以实现。当然了，这样做速度会有所损失。</p></div><hr><p>总之，线程安全是个麻烦事，在 <code>new BukkitRunnable</code> 之后<strong>一定要确认你的代码是不是线程安全的</strong>！如果不安全，最简单的方法就是<strong>把那个共享的变量改成诸如 <code>Vector</code> 这样的线程安全的实现</strong>。</p>`,39),l=[e];function r(i,c,p,k,d,y){return o(),n("div",null,l)}const u=s(t,[["render",r]]);export{v as __pageData,u as default};
