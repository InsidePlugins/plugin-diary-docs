import{_ as s,o,c as a,S as n}from"./chunks/framework.7f03344f.js";const h=JSON.parse('{"title":"2-2 事件系统概述","description":"","frontmatter":{},"headers":[],"relativePath":"Volume2/2-2.md","filePath":"docs/Volume2/2-2.md","lastUpdated":1698403164000}'),e={name:"Volume2/2-2.md"},t=n(`<h1 id="_2-2-事件系统概述" tabindex="-1">2-2 事件系统概述 <a class="header-anchor" href="#_2-2-事件系统概述" aria-label="Permalink to &quot;2-2 事件系统概述&quot;">​</a></h1><p>我们即将进入 Bukkit 中最迷人的部分：<strong>事件系统</strong>。</p><h2 id="什么是事件" tabindex="-1">什么是事件 <a class="header-anchor" href="#什么是事件" aria-label="Permalink to &quot;什么是事件&quot;">​</a></h2><p>Minecraft 中的事件有许多：</p><ul><li>玩家打开物品栏</li><li>玩家加入服务器</li><li>TNT 爆炸</li><li>服务器崩溃</li><li>……</li></ul><p>Bukkit 为这些事件都进行了分类、封装，我们可以很轻易地使用它们。</p><h2 id="可取消事件和不可取消事件" tabindex="-1">可取消事件和不可取消事件 <a class="header-anchor" href="#可取消事件和不可取消事件" aria-label="Permalink to &quot;可取消事件和不可取消事件&quot;">​</a></h2><p>在 Minecraft 的规范中，有些事件是可以被取消掉的，比如：</p><ul><li>玩家的破坏、交互、移动等</li><li>作物的生长，动物的繁殖，怪物的生成</li></ul><p>而有些事件是没法取消的，这些也显而易见：</p><ul><li>玩家加入、退出服务器</li><li>服务端崩溃</li><li>客户端发送来的数据包（可以不处理，但没法不接收）</li></ul><p>可以取消指的是<strong>可以阻止事件的进一步处理，或者在处理完成后能够恢复到之前的状态</strong>。比如玩家的移动，虽然原版 Minecraft 客户端无法阻止玩家移动，但可以通过在服务端将玩家强行送回原来的位置，再通过数据包同步到客户端。</p><p>相比之下，玩家要是强行拔掉网线，你怎么也没办法将环境恢复到之前的状态。</p><p>这里比较特殊的是玩家进入服务器，按照常规来说这应该可以取消，但是在 Bukkit 的思维模式里，玩家尝试建立连接时就已经接触了服务器，这一步没办法阻止。</p><h2 id="事件处理器" tabindex="-1">事件处理器 <a class="header-anchor" href="#事件处理器" aria-label="Permalink to &quot;事件处理器&quot;">​</a></h2><h3 id="事件驱动理论" tabindex="-1">事件驱动理论 <a class="header-anchor" href="#事件驱动理论" aria-label="Permalink to &quot;事件驱动理论&quot;">​</a></h3><p>Minecraft 的运作模式是一堆事件触发器挂着一堆事件处理器，当有事件发生时，对应的处理器就开始执行，Minecraft 由此开始运转。</p><p><img src="https://s2.loli.net/2022/04/15/94a3jAiEWZfuoxN.png" alt="EVENT.png"></p><div class="tip custom-block"><p class="custom-block-title"><img src="data:image/svg+xml,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; viewBox=&#39;0 0 1028 1024&#39; transform=&#39;scale(0.6)&#39; fill=&#39;%23fff&#39;%3E%3Cpath d=&#39;M1018.319924 112.117535q4.093748 9.210934 6.652341 21.492179t2.558593 25.585928-5.117186 26.609365-16.374994 25.585928q-12.281245 12.281245-22.003898 21.492179t-16.886712 16.374994q-8.187497 8.187497-15.351557 14.32812l-191.382739-191.382739q12.281245-11.257808 29.167958-27.121083t28.144521-25.074209q14.32812-11.257808 29.679676-15.863275t30.191395-4.093748 28.656239 4.605467 24.050772 9.210934q21.492179 11.257808 47.589826 39.402329t40.425766 58.847634zM221.062416 611.554845q6.140623-6.140623 28.656239-29.167958t56.289041-56.80076l74.710909-74.710909 82.898406-82.898406 220.038979-220.038979 191.382739 192.406177-220.038979 220.038979-81.874969 82.898406q-40.937484 39.914047-73.687472 73.175753t-54.242167 54.753885-25.585928 24.562491q-10.234371 9.210934-23.539054 19.445305t-27.632802 16.374994q-14.32812 7.16406-41.960921 17.398431t-57.824197 19.957024-57.312478 16.886712-40.425766 9.210934q-27.632802 3.070311-36.843736-8.187497t-5.117186-37.867173q2.046874-14.32812 9.722653-41.449203t16.374994-56.289041 16.886712-53.730448 13.304682-33.773425q6.140623-14.32812 13.816401-26.097646t22.003898-26.097646z&#39;/%3E%3C/svg%3E" style="background-color:#057E3D;clip-path:circle();" width="24px" height="24px"> <strong>编者注</strong></p><p>有鉴于图床失效、原图丢失，上图系定稿后再行修补，图文未必贴合。</p></div><p>当外部状态发生改变，例如有方块被破坏了，玩家移动了，对应的触发器会被激活，Bukkit 把这个事件分派到注册好的事件处理器中去处理。这就叫<strong>事件驱动</strong>。</p><p>我们的插件要想实现我们的功能，就需要改变游戏对事件的处理方式。因此，我们需要创建一个独特的事件处理器，并把它「安插」到 Bukkit 中「搞破坏」（实现我们的功能）。</p><h3 id="创建事件处理器" tabindex="-1">创建事件处理器 <a class="header-anchor" href="#创建事件处理器" aria-label="Permalink to &quot;创建事件处理器&quot;">​</a></h3><p>事件处理器是一个对象（面向对象！面向对象！），我们创建一个类来描述它：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">class</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">MyEventProcessor</span><span style="color:var(--shiki-color-text);"> {}</span></span></code></pre></div><p>你会问我了，这里是不是要 <code>extends</code> 什么东西啊？</p><p>不是，但也差不多。这里我们要使用 <code>implements</code>。</p><p>这是个啥？</p><p><code>implements</code> 和 <code>extends</code> 差不多，但它表示<strong>实现一个接口</strong>。</p><p>那啥系接口捏？</p><blockquote><p>类描述对象的属性和方法。接口则包含类要实现的方法。</p></blockquote><p>接口是一种协议。</p><p>举个例子，想象这么一个场景……</p><p>你要订酒店，在火车上你问酒店前台：「你们都有什么服务啊？」</p><p>酒店工作人员拿出了一个接口（服务单）：</p><ul><li>24 小时热水供应</li><li>免费早餐</li><li>免费 WiFi</li><li><s>免费租借 My Little Pony: Equestria Girls 四部电影的光盘</s></li></ul><p>你看了很开心，说道：「这些都能正常提供吧？」</p><p>前台回答：「是的呢亲，不会有问题的~」</p><p>交易就这么愉快地完成了。</p><hr><p>在 Java 中，接口也扮演着类似的角色。</p><ul><li>接口的<strong>调用方</strong>（这里是 Bukkit）只管调用，不管其内部如何工作</li><li>接口的<strong>实现方</strong>（这里是我们的插件）只管保证准确地完成任务，不管会被拿去做什么</li></ul><p>接口就是一纸保证书，在 Java 中协调着各个类之间的数据交换。</p><hr><p>回到 <code>implements</code> 中来。<code>implements</code> 表示「我接受任务，交给我吧，我来搞定」，由于我们要创建的是事件处理器，因此自然要接受「处理事件」的任务。</p><p><em>虽然我们要实现一个接口，但我们的事件处理器本身是一个类。</em></p><p>「处理事件」这个接口是 <code>org.bukkit.event.Listener</code>，接口的导入和类一样，都用 <code>import</code>。</p><p>因此我们的类是这样的：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">import</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">org</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">bukkit</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">event</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">Listener</span><span style="color:var(--shiki-color-text);">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">class</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">EventProcessor</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">implements</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">Listener</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span></span>
<span class="line"><span style="color:var(--shiki-color-text);">}</span></span></code></pre></div><p>Bukkit 在 <code>Listener</code> 这张「协议」上对我们的要求非常宽松：只需要实现我们需要实现的方法就可以了。</p><p>也就是说，即使我们什么也不写，以上也是一个合法的事件处理器。</p><h3 id="创建事件处理函数" tabindex="-1">创建事件处理函数 <a class="header-anchor" href="#创建事件处理函数" aria-label="Permalink to &quot;创建事件处理函数&quot;">​</a></h3><p>事件处理器中包含许多<strong>事件处理函数</strong>。每个事件处理函数处理<strong>一个事件</strong>。</p><p>一个事件处理函数的签名是这样的：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-color-text);">@</span><span style="color:var(--shiki-token-keyword);">EventHandler</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">void</span><span style="color:var(--shiki-color-text);"> 任意的函数名(事件类型 e)</span></span></code></pre></div><p>这里的 <code>@EventHandler</code> 是 Bukkit 识别事件处理函数的标志（还记得吗，我们说注解相当于关键字），该注解位于 <code>org.bukkit.event.EventHandler</code>，也需要导入。</p><p>函数名无所谓，因为 Bukkit 不依靠函数名识别事件处理函数。</p><p>所有的事件处理函数都接受一个<strong>事件</strong>对象作为参数。括号内的 <code>e</code> 只是告诉 Java：「把调用者给我的那个参数，在我这里命名为 <code>e</code> 哦~」，改成别的名字也是一样的。</p><p>这里的事件类型，即代表我们要监听的事件。</p><h3 id="查找可监听的事件" tabindex="-1">查找可监听的事件 <a class="header-anchor" href="#查找可监听的事件" aria-label="Permalink to &quot;查找可监听的事件&quot;">​</a></h3><p>Bukkit 中有许多许多的事件，那是不是哪个我们都可以监听呢？</p><p><strong>不是的</strong>，事件处理器只能监听<strong>非 <code>abstract</code></strong> 的类。</p><p><em>这一定义并不严谨，后面我们会明白这些处理器无法被监听的本质。</em></p><p>Bukkit 对可监听事件采取了详细的命名规范：<code>&lt;主语&gt;&lt;谓语&gt;Event</code></p><p>例如：</p><ul><li><code>PlayerMoveEvent</code> 玩家移动事件</li><li><code>InventoryOpenEvent</code> 物品栏被打开事件</li><li><code>EntityBreedEvent</code> 实体繁殖事件</li></ul><p>等等。</p><p>所有的事件都是 <code>org.bukkit.event.Event</code> 类的子类。这么多的事件，要怎么查找它们呢？</p><p>这里有个小技巧。</p><p>首先前往 <code>org.bukkit.event.Event</code>，你能看到 「Direct Known Subclasses」。</p><p><img src="https://s2.loli.net/2022/04/15/K8nlSweT1QPG4vm.png" alt="EVENTCLAZZ.png"></p><p>这里列出了直接子类，单击其中一个，比如 <code>PlayerEvent</code>：</p><p><img src="https://s2.loli.net/2022/04/15/I2dWsoArKBv5Ogf.png" alt="PLAYEREVENT.png"></p><p>如果这个类被 <code>abstract</code> 修饰了（图中所示），那对不起，这个事件<strong>无法被监听</strong>。请继续通过「Direct Known Subclass」查找下一级吧！这次我们选择 <code>PlayerLoginEvent</code>。</p><p><img src="https://s2.loli.net/2022/04/15/YEdcBN4VwevZXt6.png" alt="LOGINEVENT.png"></p><p>很好，这个类可以被监听。那么我们就可以将它填在参数中，然后进行处理啦！</p><h3 id="事件处理示例" tabindex="-1">事件处理示例 <a class="header-anchor" href="#事件处理示例" aria-label="Permalink to &quot;事件处理示例&quot;">​</a></h3><p>下面我们以阻止玩家移动但允许玩家转向为例，演示事件处理的方法：</p><p>先编写好类并 <code>implements Listener</code>：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">import</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">org</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">bukkit</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">event</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">Listener</span><span style="color:var(--shiki-color-text);">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">class</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">EventProcessor</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">implements</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">Listener</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">}</span></span></code></pre></div><p>一个方法监听一个事件，因此我们创建一个方法，参数中填上 <code>PlayerMoveEvent</code>。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">import</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">org</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">bukkit</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">event</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">EventHandler</span><span style="color:var(--shiki-color-text);">;</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">import</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">org</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">bukkit</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">event</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">Listener</span><span style="color:var(--shiki-color-text);">;</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">import</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">org</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">bukkit</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">event</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">player</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">PlayerMoveEvent</span><span style="color:var(--shiki-color-text);">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">class</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">EventProcessor</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">implements</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">Listener</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    @</span><span style="color:var(--shiki-token-keyword);">EventHandler</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">void</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">dontMove</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-keyword);">PlayerMoveEvent</span><span style="color:var(--shiki-color-text);"> e) {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        </span><span style="color:var(--shiki-token-comment);">// 方法名随意</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    }</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">}</span></span></code></pre></div><p>然后就该开始我们自己的表演了。</p><p>查阅 JavaDocs 可知，<code>PlayerMoveEvent</code> 有两个方法，<code>getFrom</code> 和 <code>getTo</code>。</p><p>分别调用这两个方法就可以获得两个 <code>Location</code> 对象，再利用 <code>Location</code> 自身的 <code>distance</code> 方法即可计算出距离。</p><p>如果距离不是 0，表示玩家走路了，因此调用 <code>Cancellable</code> 的 <code>setCancelled</code> 方法。</p><p>这里的 <code>Cancellable</code> 是什么呢？上面我们说到，有些事件是可取消的，有些不行。</p><p>可取消的事件实现了 <code>Cancellable</code>，具有 <code>setCancelled</code> 方法（能够完成「取消」这一任务），而没有实现的则没有这个方法（没法取消）。</p><p>综上，代码如下：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">import</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">org</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">bukkit</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">event</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">EventHandler</span><span style="color:var(--shiki-color-text);">;</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">import</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">org</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">bukkit</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">event</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">Listener</span><span style="color:var(--shiki-color-text);">;</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">import</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">org</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">bukkit</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">event</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">player</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-keyword);">PlayerMoveEvent</span><span style="color:var(--shiki-color-text);">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">class</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">EventProcessor</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">implements</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">Listener</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    @</span><span style="color:var(--shiki-token-keyword);">EventHandler</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-keyword);">public</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">void</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">dontMove</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-keyword);">PlayerMoveEvent</span><span style="color:var(--shiki-color-text);"> e) {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        </span><span style="color:var(--shiki-token-keyword);">double</span><span style="color:var(--shiki-color-text);"> distance </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">e</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">getFrom</span><span style="color:var(--shiki-color-text);">()</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">distance</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-constant);">e</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">getTo</span><span style="color:var(--shiki-color-text);">());</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        </span><span style="color:var(--shiki-token-keyword);">if</span><span style="color:var(--shiki-color-text);"> (distance </span><span style="color:var(--shiki-token-keyword);">!=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">0</span><span style="color:var(--shiki-color-text);">) {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">            </span><span style="color:var(--shiki-token-constant);">e</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">setCancelled</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-constant);">true</span><span style="color:var(--shiki-color-text);">);</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        }</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    }</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">}</span></span></code></pre></div><p>Minecraft 中用 <code>double</code>（双精度小数）计算距离。</p><p>这里出现了新的 <code>if</code> 语句，<code>if</code> 后面有对括号，其中的值如果是 <code>true</code>，就执行 <code>{}</code> 内的语句，否则跳过。</p><p><code>!=</code> 是不等于运算符：Java 比较 <code>!=</code> 两边的东西（操作对象），如果操作对象不相等，这个表达式就为 <code>true</code>，否则就为 <code>false</code>。</p><p><code>setCancelled</code> 接受一个参数，表示是否取消。</p><p>那你又要问了，Bukkit 是怎么实现取消的呢？</p><p>每个实现了 <code>Cancellable</code> 的对象中，都有一个标志标识这个事件是否被取消了。</p><p>处理函数结束时，Bukkit 看看这个标志，如果是 <code>false</code>，就将事件发往下一个事件处理器，否则就结束处理。</p><p><code>setCancelled</code> 正是用来改变这个标志的方法。</p><p>由于插件的事件处理器排在 Mojang 的事件处理器前面，因此我们具有是否取消的优先裁定权。</p><p><code>setCancelled</code> 可被多次调用，但以<strong>处理函数结束时的设定为准</strong>。</p><h3 id="注册事件处理器" tabindex="-1">注册事件处理器 <a class="header-anchor" href="#注册事件处理器" aria-label="Permalink to &quot;注册事件处理器&quot;">​</a></h3><p>创建好事件处理器后，我们还需要把它「安插」到 Bukkit 中去，这就是<strong>注册</strong>（Register）。</p><p>Bukkit 已经为我们提供了这样的方法，要注册事件，我们只需要在插件主类（继承了 <code>JavaPlugin</code> 的那个类）的 <code>onEnable</code> 方法中写上：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-constant);">Bukkit</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">getPluginManager</span><span style="color:var(--shiki-color-text);">()</span><span style="color:var(--shiki-token-punctuation);">.</span><span style="color:var(--shiki-token-function);">registerEvents</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-keyword);">new</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">EventProcessor()</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">this</span><span style="color:var(--shiki-color-text);">);</span></span></code></pre></div><p><code>this</code> 指代的是当前实例，由于这条语句在插件主类中，因此它代表的就是「插件」。</p><p><code>new EventProcessor()</code> 创建一个事件监听器的实例并交给 Bukkit 处理。这样，我们的事件就进入了服务端，开始发挥作用了。</p><hr><p>上面这里列出的只是最简单的事件处理，在后面的章节中我们会再一次见到它，届时我们将讲解自定义事件的方法。</p>`,107),l=[t];function r(p,i,c,k,v,y){return o(),a("div",null,l)}const u=s(e,[["render",r]]);export{h as __pageData,u as default};
